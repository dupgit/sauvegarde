/* config.h.  Generated from config.h.in by configure.  */
/* config.h.in.  Generated from configure.ac by autoheader.  */

/* Debug mode Off */
#define ENABLE_DEBUG FALSE

/* always defined to indicate that i18n is enabled */
#define ENABLE_NLS 1

/* Gettext Package used */
#define GETTEXT_PACKAGE "sauvegarde"

/* Define to 1 if you have the `bind_textdomain_codeset' function. */
#define HAVE_BIND_TEXTDOMAIN_CODESET 1

/* Define to 1 if you have the `dcgettext' function. */
#define HAVE_DCGETTEXT 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define if the GNU gettext() function is already present or preinstalled. */
#define HAVE_GETTEXT 1

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define if your <locale.h> file defines LC_MESSAGES. */
#define HAVE_LC_MESSAGES 1

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Locale Directory */
#define LOCALE_DIR "/home/dup/local/share/locale"

/* Define to the sub-directory in which libtool stores uninstalled libraries.
   */
#define LT_OBJDIR ".libs/"

/* Name of package */
#define PACKAGE "sauvegarde"

/* Define to the address where bug reports for this package should be sent. */
#define PACKAGE_BUGREPORT "Olivier DELHOMME <olivier.delhomme@free.fr>"

/* Define to the full name of this package. */
#define PACKAGE_NAME "sauvegarde"

/* Define to the full name and version of this package. */
#define PACKAGE_STRING "sauvegarde 0.0.2"

/* Define to the one symbol short name of this package. */
#define PACKAGE_TARNAME "sauvegarde"

/* Define to the home page for this package. */
#define PACKAGE_URL ""

/* Define to the version of this package. */
#define PACKAGE_VERSION "0.0.2"

/* git revision hash */
#define REVISION "9c300614ee06"

/* Define to 1 if you have the ANSI C header files. */
#define STDC_HEADERS 1

/* This is a Linux system */
#define SYS_LINUX 1

/* This is a Windows system using MinGW */
/* #undef SYS_MINGW */

/* Version number of package */
#define VERSION "0.0.2"
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    query.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file query.c
 * This file contains the functions to deal with queries in serveur and
 * restaure programs
 */

#include "libsauvegarde.h"



/**
 * Creates a query_t * structure filled with the corresponding datas
 * @param hostname hostname (where to look for)
 * @param uid uid for the file(s)
 * @param gid gid for the file(s)
 * @param owner owner for the file(s) hopefully corresponding to uid
 * @param group group for the file(s) hopefully corresponding to gid
 * @param filename is the filename that we are looking for.
 * @param date is the date at which we want the file's version back.
 * @returns a newly allocated query_t * structure filled  with the
 *          corresponding datas that may be freed when no longer needed.
 */
query_t *init_query_structure(gchar *hostname, gchar *uid, gchar *gid, gchar *owner, gchar *group, gchar *filename, gchar *date)
{
    query_t *query = NULL;

    query = (query_t *) g_malloc0(sizeof(query_t));

    query->hostname = hostname;
    query->uid = uid;
    query->gid = gid;
    query->owner = owner;
    query->group = group;
    query->filename = filename;
    query->date = date;

    return query;
}


/**
 * Frees a query
 * @param query is the qery to be freed
 * @returns NULL;
 */
gpointer free_query_structure(query_t *query)
{
    if (query != NULL)
        {
            free_variable(query->hostname);
            free_variable(query->uid);
            free_variable(query->gid);
            free_variable(query->owner);
            free_variable(query->group);
            free_variable(query->filename);
            free_variable(query->date);
            free_variable(query);
        }

    return NULL;
}


/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    communique.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file communique.c
 * This file contains every call to the zmq library in order to make a
 * wrapper to this library
 */

#include "libsauvegarde.h"

static size_t write_data(void *buffer, size_t size, size_t nmemb, void *userp);


/**
 * Gets the version for the communication library
 * @returns a newly allocated string that contains the version and that
 *          may be freed with free_variable() when no longer needed.
 */
gchar *get_communication_library_version(void)
{
    curl_version_info_data *data = NULL;

    data = curl_version_info(CURLVERSION_NOW);

    return g_strdup_printf(_("\t. LIBCURL version : %s\n"), data->version);
}


/**
 * Makes the connexion string that is used by ZMQ to create a new socket
 * and verifies that port number is between 1025 and 65534 included.
 * @param ip : a gchar * that contains either an ip address or a hostname
 * @param port : a gint that is comprised between 1025 and 65534 included
 * @returns a newly allocated string that may be freed with free_variable()
 *          function.
 */
gchar *make_connexion_string(gchar *ip, gint port)
{
    /**
     * @todo check the ip string to be sure that it correspond to something that
     *       we can join (IP or hostname).
     */
    gchar *conn = NULL;

    if (ip != NULL && port > 1024 && port < 65535)
        {
            /* We must ensure that ip is correct before doing this ! */
            conn = g_strdup_printf("http://%s:%d", ip, port);
        }

    return conn;
}


/**
 * Used by libcurl to retrieve informations
 * @param buffer is the buffer where received data are written by libcurl
 * @param size is the size of an element in buffer
 * @param nmemb is the number of elements in buffer
 * @param[in,out] userp is a user pointer and MUST be a pointer to comm_t *
 *                structure
 * @returns should return the size of the data taken into account.
 *          Everything different from the size passed to this function is
 *          considered as an error by libcurl.
 */
static size_t write_data(void *buffer, size_t size, size_t nmemb, void *userp)
{
    comm_t *comm = (comm_t *) userp;
    gchar *buf1 = NULL;
    gchar *concat = NULL;

    if (comm != NULL)
        {
            if (comm->seq == 0)
                {
                    comm->buffer = g_strndup(buffer, size * nmemb);
                }
            else
                {
                    buf1 = g_strndup(buffer, size * nmemb);
                    concat = g_strdup_printf("%s%s", comm->buffer, buf1);
                    free_variable(buf1);
                    free_variable(comm->buffer);
                    comm->buffer = concat;
                }

            comm->seq = comm->seq + 1;
        }

    return (size * nmemb);
}


/**
 * Uses curl to send a GET command to the http url
 * @param comm a comm_t * structure that must contain an initialized
 *        curl_handle (must not be NULL)
 * @param url a gchar * url where to send the command to. It must NOT
 *        contain the http://ip:port string. And must contain the first '/'
 *        ie to get 'http://127.0.0.1:5468/Version' url must be '/Version'.
 * @returns a CURLcode (http://curl.haxx.se/libcurl/c/libcurl-errors.html)
 *          CURLE_OK upon success, any other error code in any other
 *          situation. When CURLE_OK is returned, the datas that the server
 *          sent is in the comm->buffer gchar * string.
 */
gint get_url(comm_t *comm, gchar *url)
{
    gint success = CURLE_FAILED_INIT;
    gchar *real_url = NULL;

    if (comm != NULL && url != NULL && comm->curl_handle != NULL && comm->conn != NULL)
        {
            comm->seq = 0;
            real_url = g_strdup_printf("%s%s", comm->conn, url);

            curl_easy_setopt(comm->curl_handle, CURLOPT_URL, real_url);
            curl_easy_setopt(comm->curl_handle, CURLOPT_WRITEFUNCTION, write_data);
            curl_easy_setopt(comm->curl_handle, CURLOPT_WRITEDATA, comm);

            success = curl_easy_perform(comm->curl_handle);

            real_url = free_variable(real_url);

            if (success == CURLE_OK && comm->buffer != NULL)
                {
                    print_debug(_("Answer is: \"%s\"\n"), comm->buffer);
                }
            else
                {
                    print_error(__FILE__, __LINE__, _("Error while sending GET command and receiving datas\n"));
                }
        }

    return success;
}


/**
 * Uses curl to send a POST command to the http server url
 * @param comm a comm_t * structure that must contain an initialized
 *        curl_handle (must not be NULL). buffer field of this structure
 *        is sent as data in the POST command.
 * @param url a gchar * url where to send the command to. It must NOT
 *        contain the http://ip:port string. And must contain the first '/'
 *        ie to get 'http://127.0.0.1:5468/Version' url must be '/Version'.
 * @returns a CURLcode (http://curl.haxx.se/libcurl/c/libcurl-errors.html)
 *          CURLE_OK upon success, any other error code in any other
 *          situation. When CURLE_OK is returned, the datas that the server
 *          sent is in the comm->buffer gchar * string.
 * @todo . free some memory where needed
 *       . manage errors codes
 */
gint post_url(comm_t *comm, gchar *url)
{
    gint success = CURLE_FAILED_INIT;
    gchar *real_url = NULL;
    gchar *buffer = NULL;

    if (comm != NULL && url != NULL && comm->curl_handle != NULL && comm->conn != NULL && comm->buffer != NULL)
        {
            comm->seq = 0;

            real_url = g_strdup_printf("%s%s", comm->conn, url);
            buffer = g_strdup(comm->buffer);

            curl_easy_setopt(comm->curl_handle, CURLOPT_POSTFIELDS, buffer);
            curl_easy_setopt(comm->curl_handle, CURLOPT_URL, real_url);
            curl_easy_setopt(comm->curl_handle, CURLOPT_WRITEFUNCTION, write_data);
            curl_easy_setopt(comm->curl_handle, CURLOPT_WRITEDATA, comm);

            success = curl_easy_perform(comm->curl_handle);

            if (success != CURLE_OK)
                {
                    print_error(__FILE__, __LINE__, _("Error while sending POST command (to \"%s\") with datas\n"), real_url);
                }
            else if (comm->buffer != NULL)
                {
                    print_debug("Answer is: \"%s\"\n", comm->buffer); /** @todo  Not sure that we will need this debug information later */
                }

            free_variable(real_url);
            free_variable(buffer);
        }

    return success;
}


/**
 * Checks wether the serveur is alive or not and checks its version
 * @param comm a comm_t * structure that must contain an initialized
 *        curl_handle (must not be NULL).
 * @returns TRUE if the serveur is alive and has a correct version.
 *          FALSE otherwise
 */
gboolean is_serveur_alive(comm_t *comm)
{
    gint success = CURLE_FAILED_INIT;
    gchar *version = NULL;

    success = get_url(comm, "/Version.json");
    version = get_json_version(comm->buffer);

    free_variable(comm->buffer);

    if (success == CURLE_OK && version !=  NULL)
        {
            if (comm->conn != NULL)
                {
                    print_debug("Server (version %s) is alive at %s.\n", version, comm->conn);
                }
            else
                {
                    print_debug("Server (version %s) is alive.\n", version);
                }

            free_variable(version);
            return TRUE;
        }
    else
        {
            if (comm->conn != NULL)
                {
                    print_debug("Server is not alive (%s).\n", comm->conn);
                }
            else
                {
                    print_debug("Server is not alive.\n");
                }

            free_variable(version);
            return FALSE;
        }
}


/**
 * Creates a new communication comm_t * structure.
 * @param conn a gchar * connection string that should be some url like
 *        string : http://ip:port or http://servername:port
 * @returns a newly allocated comm_t * structure where sender and receiver
 *          are set to NULL.
 */
comm_t *init_comm_struct(gchar *conn)
{
    comm_t *comm = NULL;

    comm = (comm_t *) g_malloc0(sizeof(comm_t));

    comm->curl_handle = curl_easy_init();
    comm->buffer = NULL;
    comm->conn = conn;

    return comm;
}


/**
 * Frees and releases a comm_t * structure
 * @param comm a comm_t * structure to be freed
 */
void free_comm_t(comm_t *comm)
{
    if (comm != NULL)
        {
            curl_easy_cleanup(comm->curl_handle);
            free_variable(comm->buffer);
            free_variable(comm->conn);
            free_variable(comm);
        }
}
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    database.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file database.h
 *
 * This file contains all the definitions of the functions and structures
 * that are used to wrap database calls of Sauvegarde's project.
 */
#ifndef _DATABASE_H_
#define _DATABASE_H_


/**
 * @def DATABASE_NAME
 * Defines the database used.
 */
#define DATABASE_NAME ("SQLITE")


/**
 * @struct db_t
 * @brief Structure to store everything that is needed for the database.
 */
typedef struct
{
    sqlite3 *db;  /**< database connexion  */
} db_t;


/**
 * @struct file_row_t
 * @brief Structure that contains some fields of a files's table row
 */
typedef struct
{
    guint nb_row;        /**< number of row                       */
    GSList *id_list;     /**< list of file_ids                    */
} file_row_t;


/**
 * @returns a string containing the version of the database used.
 */
extern gchar *db_version(void);


/**
 * Returns a database
 * @param database_name is the filename of the file that contains the
 *        database
 * @result returns a db_t * filled with the database connexion or NULL
 *         in case of an error.
 */
extern db_t *open_database(gchar *database_name);


/**
 * Says whether a file is in already in the cache or not
 * @param database is the structure that contains everything that is
 *        related to the database (it's connexion for instance).
 * @param meta is the file's metadata that we want to know if it's already
 *        in the cache.
 * @returns a boolean that says TRUE if the file is already in the cache
 *          and FALSE if not.
 */
extern gboolean is_file_in_cache(db_t *database, meta_data_t *meta);


/**
 * Insert meta data into cache (db). One should have verified that the
 * file does not already exists in the database.
 * @param database is the structure that contains everything that is
 *        related to the database (it's connexion for instance).
 * @param meta is the file's metadata that we want to insert into the
 *        cache.
 * @param only_meta : a gboolean that when set to TRUE only meta_data will
 *        be saved and hashs data will not !
 */
extern void db_save_meta_data(db_t *database, meta_data_t *meta, gboolean only_meta);


/**
 * Gets all encoded hashs already inserted into the 'data' table from the
 * database.
 * @param database is the structure that contains everything that is
 *        related to the database (it's connexion for instance).
 */
/* extern hashs_t *get_all_inserted_hashs(db_t *database); */


#endif /* #ifndef _DATABASE_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    clock.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file clock.c
 * This file contains the functions to measure time.
 */

#include "libsauvegarde.h"

/**
 * Creates a new clock_t structure filled accordingly
 * @returns a clock_t * structure with begin field set.
 */
a_clock_t *new_clock_t(void)
{
    a_clock_t * my_clock = NULL;

    my_clock = (a_clock_t *) g_malloc0(sizeof(a_clock_t));

    my_clock->end = NULL;
    my_clock->begin = g_date_time_new_now_local();

    return my_clock;
}


/**
 * Ends the clock and prints the elapsed time and then frees everything
 * @param my_clock is a clock_t * structure with begin already filled
 * @param message is a message that we want to include into the displayed
 *        result in order to know what was measured.
 */
void end_clock(a_clock_t *my_clock, gchar *message)
{
    GTimeSpan difference = 0;

    if (my_clock != NULL && my_clock->begin != NULL)
        {
            my_clock->end = g_date_time_new_now_local();
            difference = g_date_time_difference(my_clock->end, my_clock->begin);

            g_date_time_unref(my_clock->begin);
            g_date_time_unref(my_clock->end);
            free_variable(my_clock);

            print_debug(_("elapsed time (%s): %d\n"), message, difference);
        }
}



/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    query.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file query.h
 *
 *  This file contains all the definitions needed by queries
 */
#ifndef _QUERY_H_
#define _QUERY_H_

/**
 * @struct query_t
 * @brief This structure is used to pass parameters to query functions.
 * Fields of this structure may be searched into the selected backend.
 */
typedef struct
{
    gchar *hostname;
    gchar *uid;
    gchar *gid;
    gchar *owner;
    gchar *group;
    gchar *filename;
    gchar *date;
} query_t;


/**
 * Creates a query_t * structure filled with the corresponding datas
 * @param hostname hostname (where to look for)
 * @param uid uid for the file(s)
 * @param gid gid for the file(s)
 * @param owner owner for the file(s) hopefully corresponding to uid
 * @param group group for the file(s) hopefully corresponding to gid
 * @returns a newly allocated query_t * structure filled  with the
 *          corresponding datas that may be freed when no longer needed.
 */
extern query_t *init_query_structure(gchar *hostname, gchar *uid, gchar *gid, gchar *owner, gchar *group, gchar *filename, gchar *date);


/**
 * Frees a query
 * @param query is the qery to be freed
 * @returns NULL;
 */
extern gpointer free_query_structure(query_t *query);

#endif /* #ifndef _QUERY_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    packing.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file packing.c
 * This file contains the functions to pack messages for all the
 * programs of "Sauvegarde" project.
 * @todo add a field that will say what is the message packed into the
 * string (meta_data_t * or a some sort of data_t * or something else ?).
 */

#include "libsauvegarde.h"

static void insert_string_into_json_root(json_t *root, gchar *keyname, gchar *a_string);
static void insert_guint8_into_json_root(json_t *root, gchar *keyname, guint8 number);
static void insert_guint32_into_json_root(json_t *root, gchar *keyname, guint32 number);
static void insert_guint64_into_json_root(json_t *root, gchar *keyname, guint64 number);


/**
 * Inserts a json_t *value into the json_t *root array.
 * @param[in,out] root is the root that will contain all meta data values
 * @param keyname is the keyname associated with the value (in fact it is
 *        variable's name)
 * @param value is the json_t "encoded" value to insert into the root
 */
void insert_json_value_into_json_root(json_t *root, gchar *keyname, json_t *value)
{
    int result = 0;

    if (root != NULL && keyname != NULL && value != NULL)
        {
            result = json_object_set_new(root, keyname, value);

            if (result != JANSSON_SUCCESS)
                {
                    print_error( __FILE__, __LINE__, _("Error while converting to JSON\n"));
                    exit(EXIT_FAILURE); /* An error here means that we will do nothing good */
                }
        }
}


/**
 * appends a string into the array (the array is ordered and should
 * not mess itself)
 * @param[in,out] array is an array of strings (may be hashs of filenames
 *                for instance.
 * @param to_append is the string to be appended to the array
 */
void append_string_to_array(json_t *array, gchar *to_append)
{
    json_t *string = NULL;

    if (array != NULL && to_append != NULL)
        {
            string = json_string_nocheck((const char *) to_append);

            json_array_append_new(array, string);
        }
}


/**
 * Inserts the string a_string into the json tree root with key keyname.
 * @param[in,out] root is the main json tree
 * @param keyname is the key for which we will insert a new value
 * @param a_string is the value to be inserted with key keyname.
 */
static void insert_string_into_json_root(json_t *root, gchar *keyname, gchar *a_string)
{
    json_t *str = NULL;

    if (root != NULL && keyname != NULL && a_string != NULL)
        {
            str = json_string_nocheck((const char *) a_string);
            insert_json_value_into_json_root(root, keyname, str);
        }
}


/**
 * Inserts the guint8 number into the json tree root with key keyname.
 * @param[in,out] root is the main json tree
 * @param keyname is the key for which we will insert a new value
 * @param number is the value to be inserted with key keyname.
 */
static void insert_guint8_into_json_root(json_t *root, gchar *keyname, guint8 number)
{
    json_t *value = NULL;

    if (root != NULL && keyname != NULL)
        {
            value = json_integer(number);
            insert_json_value_into_json_root(root, keyname, value);
        }
}


/**
 * Inserts the guint32 number into the json tree root with key keyname.
 * @param[in,out] root is the main json tree
 * @param keyname is the key for which we will insert a new value
 * @param number is the value to be inserted with key keyname.
 */
static void insert_guint32_into_json_root(json_t *root, gchar *keyname, guint32 number)
{
    json_t *value = NULL;

    if (root != NULL && keyname != NULL)
        {
            value = json_integer(number);
            insert_json_value_into_json_root(root, keyname, value);
        }
}


/**
 * Inserts the guint64 number into the json tree root with key keyname.
 * @param[in,out] root is the main json tree
 * @param keyname is the key for which we will insert a new value
 * @param number is the value to be inserted with key keyname.
 */
static void insert_guint64_into_json_root(json_t *root, gchar *keyname, guint64 number)
{
    json_t *value = NULL;

    if (root != NULL && keyname != NULL)
        {
            value = json_integer(number);
            insert_json_value_into_json_root(root, keyname, value);
        }
}


/**
 * Converts the hash list to a json_t * array
 * @param hash_list : the GSList * list of hashs
 * @returns a json_t * array with the element of the list in it (if any).
 * @todo : I'm not sure that the order of the list is respected when using
 *         json. We should explicit this order :
 *         [ {number : n, hash : sdsdd}, {number : m, hash : sazsdd}, ... ]
 */
json_t *convert_hash_list_to_json(GSList *hash_list)
{
    json_t *array = NULL;           /** json_t *array is the array that will receive base64 encoded hashs        */
    gchar *encoded_hash = NULL;     /** gchar encoded_hash is an hash base64 encoded                             */
    GSList *head = NULL;            /** GSList *head is a list to iter over that will contain the hash data list */
    hash_data_t *hash_data = NULL;  /** A pointer to get the hash_data structure */

    /* creating an array with the whole hash list */
    array = json_array();
    head = hash_list;

    while (head != NULL)
        {
            hash_data = head->data;
            encoded_hash = g_base64_encode(hash_data->hash, HASH_LEN);

            append_string_to_array(array, encoded_hash);

            free_variable(encoded_hash);

            head = g_slist_next(head);
        }

    return array;
}


/**
 * Converts the file list (a list of gchar *) to a json_t * array
 * @param file_list : the GSList * list of hashs
 * @returns a json_t * array with the element of the list in it (if any).
 */
json_t *convert_file_list_to_json(GSList *file_list)
{
    json_t *array = NULL;       /** json_t *array is the array that will receive base64 encoded hashs   */
    GSList *head = NULL;        /** GSList *head is a list to iter over that will contain the hash list */

    /* creating an array with the whole hash list */
    array = json_array();
    head = file_list;

    while (head != NULL)
        {
            append_string_to_array(array, head->data);

            head = g_slist_next(head);
        }

    return array;
}


/**
 * Converts the file list (a list of gchar *) to a json string
 * @param file_list : the GSList * list of hashs
 * @returns a gchar * string json formatted with all files (if any) in a
 *          json array
 */
gchar *convert_file_list_to_json_string(GSList *file_list)
{
    json_t *array = NULL;
    json_t *root = NULL;
    gchar *string = NULL;

    root = json_object();

    array = convert_file_list_to_json(file_list);

    insert_json_value_into_json_root(root, "file_list", array);

    string = json_dumps(root, 0);

    json_decref(array);
    json_decref(root);

    return string;
}


/**
 * Converts data with the associated hash to a json formatted string
 * @param a_data the data structure that contains the data whose checksum
 *               is a_hash
 * @param encoded_hash the hash of the data contained in a_data in base64
 *        encoded format.
 * @returns a json formatted string with those informations
 */
gchar *convert_data_to_json(data_t *a_data, gchar *encoded_hash)
{
    gchar *encoded_data = NULL;
    gchar *json_str = NULL;
    json_t *root = NULL;

    if (a_data != NULL && encoded_hash != NULL && a_data->buffer != NULL && a_data->read >= 0)
        {
            encoded_data = g_base64_encode((guchar*) a_data->buffer, a_data->read);

            root = json_object();
            insert_string_into_json_root(root, "hash", encoded_hash);
            insert_string_into_json_root(root, "data", encoded_data);
            insert_guint64_into_json_root(root, "size", a_data->read);
            json_str = json_dumps(root, 0);

            json_decref(root);
            free_variable(encoded_data);
        }

    return json_str;
}


/**
 * Converts hash_data_t structure  to a json formatted string.
 * @param hash_data the hash_data_t structure that contains the data to
 *        be converted.
 * @returns a json formatted string with those informations
 */
gchar *convert_hash_data_t_to_json(hash_data_t *hash_data)
{
    gchar *encoded_data = NULL;
    gchar *encoded_hash = NULL;
    gchar *json_str = NULL;
    json_t *root = NULL;

    if (hash_data != NULL && hash_data->data != NULL && hash_data->hash != NULL && hash_data->read >= 0)
        {
            encoded_data = g_base64_encode((guchar*) hash_data->data, hash_data->read);
            encoded_hash = g_base64_encode((guchar*) hash_data->hash, HASH_LEN);

            root = json_object();
            insert_string_into_json_root(root, "hash", encoded_hash);
            insert_string_into_json_root(root, "data", encoded_data);
            insert_guint64_into_json_root(root, "size", hash_data->read);
            json_str = json_dumps(root, 0);

            json_decref(root);
            free_variable(encoded_data);
            free_variable(encoded_hash);
        }

    return json_str;
}



/**
 * This function should return a JSON object with all informations from
 * the meta_data_t structure.
 * @param meta is the structure that contains all meta data for a file or
 *        a directory.
 * @param hostname is the name of the host onw hich we are running and that
 *        we want to include into the json string.
 * @returns a json_t structure or NULL
 */
json_t *convert_meta_data_to_json(meta_data_t *meta, const gchar *hostname)
{
    json_t *root = NULL;        /** json_t *root is the root that will contain all meta data json       */
    json_t *array = NULL;       /** json_t *array is the array that will receive base64 encoded hashs   */

    if (meta != NULL)
        {
            root = json_object();

            insert_guint8_into_json_root(root, "msg_id", ENC_META_DATA);
            insert_guint8_into_json_root(root, "filetype", meta->file_type);
            insert_guint32_into_json_root(root, "mode", meta->mode);

            insert_guint64_into_json_root(root, "atime", meta->atime);
            insert_guint64_into_json_root(root, "ctime", meta->ctime);
            insert_guint64_into_json_root(root, "mtime", meta->mtime);
            insert_guint64_into_json_root(root, "fsize", meta->size);
            insert_guint64_into_json_root(root, "inode", meta->inode);

            insert_string_into_json_root(root, "owner", meta->owner);
            insert_string_into_json_root(root, "group", meta->group);

            insert_guint32_into_json_root(root, "uid", meta->uid);
            insert_guint32_into_json_root(root, "gid", meta->uid);

            insert_string_into_json_root(root, "name", meta->name);
            insert_string_into_json_root(root, "link", meta->link);
            insert_string_into_json_root(root, "hostname", (gchar *) hostname);

            array = convert_hash_list_to_json(meta->hash_data_list);

            insert_json_value_into_json_root(root, "hash_list", array);
        }

    return root;
}


/**
 * This function should return a JSON string with all informations from
 * the meta_data_t structure.
 * @param meta is the structure that contains all meta data for a file or
 *        a directory.
 * @param hostname is the name of the host onw hich we are running and that
 *        we want to include into the json string.
 * @returns a JSON formated string or NULL
 */
gchar *convert_meta_data_to_json_string(meta_data_t *meta, const gchar *hostname)
{
    json_t *root = NULL;        /** json_t *root is the root that will contain all meta data json       */
    gchar *json_str = NULL;     /** gchar *json_str is the string to be returned at the end             */


    if (meta != NULL)
        {
            root = convert_meta_data_to_json(meta, hostname);
            json_str = json_dumps(root, 0);
            json_decref(root);
        }

    return json_str;
}


/**
 * Converts to a json gchar * string. Used only by serveur's program
 * @param name : name of the program of which we want to print the version.
 * @param date : publication date of this version
 * @param version : version of the program.
 * @param authors : authors that contributed to this program
 * @param license : license in use for this program and its sources
 * @returns a newlly allocated gchar * string in json format that can be
 *          freed when no longer needed.
 */
gchar *convert_version_to_json(gchar *name, gchar *date, gchar *version, gchar *authors, gchar *license)
{
    json_t *root = NULL;    /** json_t *root is the root that will contain all data in json format     */
    json_t *libs = NULL;    /** json_t *libs is the array that will contain all libraries and versions */
    json_t *auths = NULL;   /** json_t *auths is the array containing all authors                      */
    json_t *objs = NULL;    /** json_t *objs will store version of libraries                           */
    gchar *buffer = NULL;
    gchar *json_str = NULL; /** gchar *json_str is the string to be returned at the end                */


    root = json_object();

    insert_string_into_json_root(root, "name", name);
    insert_string_into_json_root(root, "date", date);
    insert_string_into_json_root(root, "version", version);
    insert_string_into_json_root(root, "revision", REVISION);
    insert_string_into_json_root(root, "licence", license);

    /**
     * @todo use g_strsplit to split authors string if more than one author
     * is in the string.
     */
    auths = json_array();
    json_array_append_new(auths, json_string(authors));
    insert_json_value_into_json_root(root, "authors", auths);



    libs = json_array();

    /* glib */
    buffer = g_strdup_printf("%d.%d.%d", glib_major_version, glib_minor_version, glib_micro_version);
    objs = json_object();
    json_object_set_new(objs, "glib", json_string(buffer));
    json_array_append_new(libs, objs);
    free_variable(buffer);

    /* libmicrohttpd */
    buffer = make_MHD_version();
    objs = json_object();
    json_object_set_new(objs, "mhd", json_string(buffer));
    json_array_append_new(libs, objs);
    free_variable(buffer);

    /* sqlite */
    buffer = g_strdup_printf("%s", db_version());
    objs = json_object();
    json_object_set_new(objs, "sqlite", json_string(buffer));
    json_array_append_new(libs, objs);
    free_variable(buffer);

    /* jansson ! */
    buffer = g_strdup_printf("%d.%d.%d", JANSSON_MAJOR_VERSION, JANSSON_MINOR_VERSION, JANSSON_MICRO_VERSION);
    objs = json_object();
    json_object_set_new(objs, "jansson", json_string(buffer));
    json_array_append_new(libs, objs);
    free_variable(buffer);

    insert_json_value_into_json_root(root, "librairies", libs);

    json_str = json_dumps(root, 0);

    json_decref(root);

    return json_str;

}


/**
 * Function that encapsulate a meta_data_t * variable into a capsule_t *
 * one. It does not check that meta is not NULL so it may encapsulate a
 * NULL pointer !
 * @param command is the command to be used with the encapsulated data.
 * @param meta is the meta_data_t * variable to be encapsulated
 * @returns a capsule_t * with command field set to ENC_META_DATA stating
 *          that the data field is of type meta_data_t *.
 */
capsule_t *encapsulate_meta_data_t(gint command, meta_data_t *meta)
{

    capsule_t *capsule = NULL;

    capsule = (capsule_t *) g_malloc0(sizeof(capsule_t));

    capsule->command = command;
    capsule->data = (void *) meta;

    return capsule;
}


/**
 * Function that encapsulate an END command.
 * @returns a capsule_t * with command field set to ENC_END stating
 *          that this is the end my friend (some famous song) !
 */
capsule_t *encapsulate_end(void)
{
    return encapsulate_meta_data_t(ENC_END, NULL);
}


/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    database.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file database.c
 * This file contains the functions to wrap database calls in all the
 * programs of "Sauvegarde" project.
 */

#include "libsauvegarde.h"

static void print_db_error(sqlite3 *db, const char *format, ...);
static void exec_sql_cmd(db_t *database, gchar *sql_cmd, gchar *format_message);
static int table_callback(void *num, int nbCol, char **data, char **nomCol);
static void verify_if_tables_exists(db_t *database);
static file_row_t *new_file_row_t(void);
static void free_file_row_t(file_row_t *row);
static int get_file_callback(void *a_row, int nb_col, char **data, char **name_col);
static file_row_t *get_file_id(db_t *database, meta_data_t *meta);
static int get_data_callback(void *a_data, int nb_col, char **data, char **name_col);
static data_t *get_data_from_checksum(db_t *database, gchar *encoded_hash);

/**
 * @returns a string containing the version of the database used.
 */
gchar *db_version(void)
{
    return (gchar *) sqlite3_libversion();
}


/**
 * Prints an error message to stderr and exit (db errors are considered as
 * fatal for now).
 * @param db : file connexion to the database.
 * @param format : the format of the message (as in printf)
 * @param ... : va_list of variable that are to be printed into format.
 */
static void print_db_error(sqlite3 *db, const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    vfprintf(stderr, format, ap);
    va_end(ap);

    sqlite3_close(db);
    exit(EXIT_FAILURE);
}


/**
 * Executes the SQL command onto the database without any callback
 * @param database : the db_t * structure that contains the database connexion
 * @param sql_cmd : a gchar * SQL command to be executed onto the database
 * @param format_message : a gchar * format message to be used in case of an error
 */
static void exec_sql_cmd(db_t *database, gchar *sql_cmd, gchar *format_message)
{
    char *error_message = NULL;
    int result = 0;

    result = sqlite3_exec(database->db, sql_cmd, NULL, 0, &error_message);

    if (result != SQLITE_OK)
        {
            print_db_error(database->db, format_message, result, error_message);
        }
}


/**
 * Counts the number of row that we have by incrementing i.
 * @param num is an integer that will count the number of rows in the result.
 * @param nb_col gives the number of columns in this row.
 * @param data contains the data of each column.
 * @param name_col contains the name of each column.
 * @returns always 0.
 */
static int table_callback(void *num, int nb_col, char **data, char **name_col)
{
    int *i = (int *) num;

    *i = *i + 1;

    return 0;
}


/**
 * Verifies if the tables are created whithin the database and creates
 * them if there is no tables at all.
 * @param database : the structure to manage database's connexion.
 */
static void verify_if_tables_exists(db_t *database)
{
    char *error_message = NULL;
    int result = 0;
    int *i = NULL;               /** int *i is used to count the number of row */

    i = (int *) g_malloc0(sizeof(int));
    *i = 0;

    /* Trying to get all the tables that are in the database */
    result = sqlite3_exec(database->db, "SELECT * FROM sqlite_master WHERE type='table';", table_callback, i, &error_message);

    if (result == SQLITE_OK && *i == 0)  /* No row (0) means that there is no table */
        {
            print_debug(_("Creating tables into the database\n"));

            /* The database does not contain any tables. So we have to create them.         */
            /* Creation of checksum table that contains checksums and their associated data */
            exec_sql_cmd(database, "CREATE TABLE data (checksum TEXT PRIMARY KEY, size INTEGER, data TEXT);", _("(%d) Error while creating database table 'data': %s\n"));

            /* Creation of buffers table that contains checksums and their associated data */
            exec_sql_cmd(database, "CREATE TABLE buffers (cache_time INTEGER, buf_order INTEGER, checksum TEXT);", _("(%d) Error while creating database table 'buffers': %s\n"));

            /* Creation of files table that contains everything about a file */
            exec_sql_cmd(database, "CREATE TABLE files (file_id  INTEGER PRIMARY KEY AUTOINCREMENT, cache_time INTEGER, type INTEGER, inode INTEGER, file_user TEXT, file_group TEXT, uid INTEGER, gid INTEGER, atime INTEGER, ctime INTEGER, mtime INTEGER, mode INTEGER, size INTEGER, name TEXT, transmitted BOOL, link TEXT);", _("(%d) Error while creating database table 'files': %s\n"));
        }

    free_variable(i);

    /**
     * We are setting the asynchronous mode of SQLITE here. Tradeoff is that any
     * powerloss is leading to a database corruption and data loss !
     * @todo make this PRAGMA selection an option from the command line.
     */
    /* exec_sql_cmd(database, "PRAGMA synchronous = OFF;", _("Error while trying to set asynchronous mode.\n")); */

}


/**
 * Says whether a file is in already in the cache or not
 * @param database is the structure that contains everything that is
 *        related to the database (it's connexion for instance).
 * @param meta is the file's metadata that we want to know if it's already
 *        in the cache.
 * @returns a boolean that says TRUE if the file is already in the cache
 *          and FALSE if not.
 */
gboolean is_file_in_cache(db_t *database, meta_data_t *meta)
{
    file_row_t *row = NULL;

    if (meta != NULL && database != NULL)
        {

            row = get_file_id(database, meta);

            if (row != NULL)
                {
                    if (row->nb_row == 0) /* No row has been returned. It means that the file isn't in the cache */
                        {
                            free_file_row_t(row);
                            return FALSE;
                        }
                    else
                        { /* At least one row has been returned */
                            free_file_row_t(row);
                            return TRUE;
                        }
                }
            else
                {
                    return FALSE;
                }
        }
    else
        {
            return FALSE;
        }
}


/**
 * Gets file_ids from returned rows.
 * @param a_row is a file_row_t * structure
 * @param nb_col gives the number of columns in this row.
 * @param data contains the data of each column.
 * @param name_col contains the name of each column.
 * @returns always 0.
 */
static int get_file_callback(void *a_row, int nb_col, char **data, char **name_col)
{
    file_row_t *row = (file_row_t *) a_row;

    row->nb_row = row->nb_row + 1;
    row->id_list = g_slist_append(row->id_list, g_strdup(data[0]));

    return 0;
}


/**
 * Returns the file_id for the specified file.
 * @param database is the structure that contains everything that is
 *        related to the database (it's connexion for instance).
 * @param meta is the file's metadata that we want to insert into the
 *        cache.
 * @returns a file_row_t structure filed with values returned by the
 *          database.
 */
static file_row_t *get_file_id(db_t *database, meta_data_t *meta)
{
    file_row_t *row = NULL;
    char *error_message = NULL;
    gchar *sql_command = NULL;
    int db_result = 0;

    row = new_file_row_t();

    sql_command = g_strdup_printf("SELECT file_id from files WHERE inode=%" G_GUINT64_FORMAT " AND name='%s' AND type=%d AND uid=%d AND gid=%d AND ctime=%" G_GUINT64_FORMAT " AND mtime=%" G_GUINT64_FORMAT " AND mode=%d AND size=%" G_GUINT64_FORMAT ";", meta->inode, meta->name, meta->file_type, meta->uid, meta->gid, meta->ctime, meta->mtime, meta->mode, meta->size);

    db_result = sqlite3_exec(database->db, sql_command, get_file_callback, row, &error_message);

    free_variable(sql_command);

    if (db_result == SQLITE_OK)
        {
           return row;
        }
    else
        {
            print_db_error(database->db, _("(%d) Error while searching into the table 'files': %s\n"), db_result, error_message);
            return NULL; /* to avoid a compilation warning as we exited with failure in print_db_error */
        }
}


/**
 * Creates and inits a new file_row_t * structure.
 * @returns an empty file_row_t * structure.
 */
static file_row_t *new_file_row_t(void)
{
    file_row_t *row = NULL;

    row = (file_row_t *) g_malloc0(sizeof(file_row_t));

    row->nb_row = 0;
    row->id_list = NULL;

    return row;
}


/**
 * Frees everything whithin the file_row_t structure
 * @param row is the variable to be freed totaly
 */
static void free_file_row_t(file_row_t *row)
{
    if (row != NULL)
        {
            g_slist_free_full(row->id_list, free_gchar_variable);
            free_variable(row);
        }
}


/**
 * Gets file_ids from returned rows.
 * @param a_data is a data_t * structure
 * @param nb_col gives the number of columns in this row.
 * @param data contains the data of each column.
 * @param name_col contains the name of each column.
 * @returns always 0.
 */
static int get_data_callback(void *a_data, int nb_col, char **data, char **name_col)
{
    data_t *my_data = (data_t *) a_data;

    if (data != NULL)
        {
            my_data->read = g_ascii_strtoull(data[0], NULL, 10);
            my_data->buffer = (guchar *) g_strdup(data[1]);
        }

    return 0;
}


/**
 * Gets data from a checksum
 * @param database is the structure that contains everything that is
 *        related to the database (it's connexion for instance).
 * @param encoded_hash is the checksum base64 encoded.
 * @returns a newly allocated data_t structure which may contain the data
 *          for the specified base64 encoded hash (checksum).
 */
static data_t *get_data_from_checksum(db_t *database, gchar *encoded_hash)
{
    data_t *a_data = NULL;
    char *error_message = NULL;
    gchar *sql_command = NULL;
    int db_result = 0;

    a_data = new_data_t_structure(NULL, 0, TRUE); /* TRUE as we are retreiving from the cache */

    sql_command = g_strdup_printf("SELECT size, data FROM data WHERE checksum='%s' ;", encoded_hash);

    db_result = sqlite3_exec(database->db, sql_command, get_data_callback, a_data, &error_message);

    free_variable(sql_command);

    if (db_result == SQLITE_OK)
        {
           return a_data;
        }
    else
        {
            print_db_error(database->db, _("(%d) Error while searching into the table 'data': %s\n"), db_result, error_message);
            return NULL; /* to avoid a compilation warning as we exited with failure in print_db_error */
        }
}



/**
 * Gets all encoded hashs already inserted into the 'data' table from the
 * database.
 * @param database is the structure that contains everything that is
 *        related to the database (it's connexion for instance).
 * @returns a hashs_t * structure that contains all hashs that are in the
 *          'data' table of the database but without it's datas (the buffer
 *          field is set to NULL but into_cache is set to TRUE).
 */
 /*
hashs_t *get_all_inserted_hashs(db_t *database)
{
    hashs_t *inserted_hashs = NULL;
    char *error_message = NULL;
    gchar *sql_command = NULL;
    int db_result = 0;

    inserted_hashs = new_hash_struct();

    sql_command = g_strdup_printf("SELECT checksum, size FROM data;");

    db_result = sqlite3_exec(database->db, sql_command, get_all_checksum_callback, inserted_hashs, &error_message);

    free_variable(sql_command);

    if (db_result == SQLITE_OK)
        {
           return inserted_hashs;
        }
    else
        {
            print_db_error(database->db, _("(%d) Error while searching into the table 'data': %s\n"), db_result, error_message);
            return NULL;  to avoid a compilation warning as we exited with failure in print_db_error
        }
}
*/


/**
 * Insert file into cache. One should have verified that the file
 * does not already exists in the database.
 * @note insert_file_into_cache is fast but does not garantee that the
 *       data is on the disk !
 * @param database is the structure that contains everything that is
 *        related to the database (it's connexion for instance).
 * @param meta is the file's metadata that we want to insert into the
 *        cache.
 * @param only_meta : a gboolean that when set to TRUE only meta_data will
 *        be saved and hashs data will not ! FALSE means that something
 *        went wrong with serveur and that all data will be cached localy.
 */
void db_save_meta_data(db_t *database, meta_data_t *meta, gboolean only_meta)
{
    gchar *sql_command = NULL;     /** gchar *sql_command is the command to be executed */
    guint64 cache_time = 0;

    if (meta != NULL && database != NULL)
        {
            cache_time = g_get_real_time();

            /* beginning a transaction */
            exec_sql_cmd(database, "BEGIN;",  _("(%d) Error openning the transaction: %s\n"));

            /* Inserting the file into the files table */
            sql_command = g_strdup_printf("INSERT INTO files (cache_time, type, inode, file_user, file_group, uid, gid, atime, ctime, mtime, mode, size, name, transmitted, link) VALUES (%" G_GUINT64_FORMAT ", %d, %" G_GUINT64_FORMAT ", '%s', '%s', %d, %d, %" G_GUINT64_FORMAT ", %" G_GUINT64_FORMAT ", %" G_GUINT64_FORMAT ", %d, %" G_GUINT64_FORMAT ", '%s', %d, '%s');", cache_time, meta->file_type, meta->inode, meta->owner, meta->group, meta->uid, meta->gid, meta->atime, meta->ctime, meta->mtime, meta->mode, meta->size, meta->name, only_meta, meta->link);

            exec_sql_cmd(database, sql_command,  _("(%d) Error while inserting into the table 'files': %s\n"));

            free_variable(sql_command);

            /* ending the transaction here */
            exec_sql_cmd(database, "COMMIT;",  _("(%d) Error commiting to the database: %s\n"));
        }
}


/**
 * Returns a database connexion or NULL.
 * @param database_name is the filename of the file that contains the
 *        database
 * @result returns a db_t * filled with the database connexion or NULL
 *         in case of an error.
 */
db_t *open_database(gchar *database_name)
{
    db_t *database = NULL;
    sqlite3 *db = NULL;
    int result = 0;

    database = (db_t *) g_malloc0(sizeof(db_t));

    result = sqlite3_open(database_name, &db);

    if (result != SQLITE_OK)
        {
            print_db_error(db, _("(%d) Error while trying to open %s database: %s\n"), result, database_name, sqlite3_errmsg(db));
            free_variable(database);
            sqlite3_close(db);

            return NULL;
        }
    else
        {
            database->db = db;
            verify_if_tables_exists(database);

            return database;
        }
}




/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    packing.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file packing.h
 *
 * This file contains all the definitions of the functions and structures
 * to pack and unpack messages for all the programs of "Sauvegarde"
 * project.
 */
#ifndef _PACKING_H_
#define _PACKING_H_

/**
 * @def JANSSON_SUCCESS
 * Defines jansson success answer
 */
#define JANSSON_SUCCESS (0)


/**
 * @def ENC_NOT_FOUND
 * Indicates that something is wrong :
 *  - msg_id was not found into the JSON string.
 */
#define ENC_NOT_FOUND (0)


/**
 * @def ENC_META_DATA
 * Indicates that the encapsulated data is a meta_data_t * variable.
 */
#define ENC_META_DATA (1)


/**
 * @def IS_SERVEUR_UP
 * Indicates that we want to know if the serveur server is up.
 */
#define IS_SERVEUR_UP (2)


/**
 * @def ENC_END
 * Indicates that this is the end and that nothing else with occur after !
 * 127 is the end of the 7 bits ASCII table ;-)
 */
#define ENC_END (127)


/**
 * @struct capsule_t
 * @brief This structure encapsulate some commands and data that has
 *        to be transmited to antememoire's storing thread.
 */
typedef struct
{
    gint command; /**< Is an integer that says what to do based on ENC_*
                   *   macros
                   */
    void *data;   /**< Is a pointer to some structure. Type of the structure
                   *   is determined by the command parameter
                   */
} capsule_t;


/**
 * This function loads a JSON string into a json_t struture
 * @param json_str is the json string
 * @returns a pointer to a filled json_t * structure or NULL upon error
 */
extern json_t *load_json(gchar *json_str);


/**
 * Inserts a json_t *value into the json_t *root array.
 * @param[in,out] root is the root that will contain all meta data values
 * @param keyname is the keyname associated with the value (in fact it is
 *        variable's name)
 * @param value is the json_t "encoded" value to insert into the root
 */
extern void insert_json_value_into_json_root(json_t *root, gchar *keyname, json_t *value);


/**
 * appends a string into the array (the array is ordered and should
 * not mess itself)
 * @param[in,out] array is an array of strings (may be hashs of filenames
 *                for instance.
 * @param to_append is the string to be appended to the array
 */
extern void append_string_to_array(json_t *array, gchar *to_append);


/**
 * gets a json_t *value into the json_t *root array.
 * @param[in,out] root is the root that contains all meta data values
 * @param keyname is the keyname associated with the value that we want to
 *        get back.
 * @returns the json_t "encoded" value from key keyname from the root
 */
extern json_t *get_json_value_from_json_root(json_t *root, gchar *keyname);


/**
 * returns the string with key keyname from the json tree root. It is used
 * by serveur to get the hostname from the json received message.
 * @param[in,out] root is the main json tree
 * @param keyname is the key for which we seek the string value.
 * @returns a newlly allocated gchar * string that is the value associated
 *          with key keyname. It can be freed with free_variable() when no longer
 *          needed.
 */
extern gchar *get_string_from_json_root(json_t *root, gchar *keyname);


/**
 * Converts the hash list to a json_t * array
 * @param hash_list : the GSList * list of hashs
 * @returns a json_t * array with the element of the list in it (if any).
 */
extern json_t *convert_hash_list_to_json(GSList *hash_list);


/**
 * Converts the file list to a json_t * array
 * @param file_list : the GSList * list of hashs
 * @returns a json_t * array with the element of the list in it (if any).
 */
extern json_t *convert_file_list_to_json(GSList *file_list);


/**
 * Converts the file list (a list of gchar *) to a json string
 * @param file_list : the GSList * list of hashs
 * @returns a gchar * string json formatted with all files (if any) in a
 *          json array
 */
extern gchar *convert_file_list_to_json_string(GSList *file_list);


/**
 * This function returns a list from an json array
 * @param root is the root json string that may contain an array named "name"
 * @param name is the name of the array to look for into
 * @returns a GSList that me be composed of 0 element (ie NULL). Elements
 *          are of type gchar *.
 */
extern GSList *extract_gslist_from_array(json_t *root, gchar *name);


/**
 * This function returns a list from an json array.
 * @param root is the root json string that must contain an array named
 *        "file_list"
 * @returns a GSList that may be composed of 0 element (ie NULL). Elements
 *          are of type serveur_meta_data_t *.
 */
extern GSList *extract_smeta_gslist_from_file_list(json_t *root);


/**
 * Converts data with the associated hash to a json formatted string
 * @param a_data the data structure that contains the data whose checksum
 *               is a_hash
 * @param encoded_hash the hash of the data contained in a_data in base64
 *        encoded format.
 * @returns a json formatted string with those informations
 */
extern gchar *convert_data_to_json(data_t *a_data, gchar *encoded_hash);


/**
 * This function should return a JSON object with all informations from
 * the meta_data_t structure.
 * @param meta is the structure that contains all meta data for a file or
 *        a directory.
 * @param hostname is the name of the host onw hich we are running and that
 *        we want to include into the json string.
 * @returns a json_t structure or NULL
 */
extern json_t *convert_meta_data_to_json(meta_data_t *meta, const gchar *hostname);


/**
 * This function should return a JSON string with all informations from
 * the meta_data_t structure.
 * @param meta is the structure that contains all meta data for a file or
 *        a directory.
 * @param hostname is the name of the host on which we are running and that
 *        we want to include into the json string.
 * @returns a JSON formated string or NULL
 */
extern gchar *convert_meta_data_to_json_string(meta_data_t *meta, const gchar *hostname);


/**
 * Function that converts json_str containing the keys "hash", "data"
 * and "read" into hash_data_t structure.
 * @param json_str is a json string containing the keys "hash", "data"
 *        and read
 * @returns a newly allocated hash_data_t structure with the
 *          corresponding datas in it.
 */
extern hash_data_t *convert_json_to_hash_data(gchar *json_str);

/**
 * Converts hash_data_t structure  to a json formatted string.
 * @param hash_data the hash_data_t structure that contains the data to
 *        be converted.
 * @returns a json formatted string with those informations
 */
extern gchar *convert_hash_data_t_to_json(hash_data_t *hash_data);

/**
 * This function should return a newly allocated meta_data_t * structure
 * with all informations included from the json string.
 * @param json_str is a gchar * contianing the JSON formated string.
 * @returns a newly_allocated meta_data_t * structure that can be freed
 *          with free_meta_data_t() function when no longer needed. This
 *          function can return NULL if json_str is NULL itself.
 */
extern serveur_meta_data_t *convert_json_to_smeta_data(gchar *json_str);


/**
 * Function that encapsulate a meta_data_t * variable into a capsule_t *
 * one. It does not check that meta is not NULL so it may encapsulate a
 * NULL pointer !
 * @param command is the command to be used with the encapsulated data.
 * @param meta is the meta_data_t * variable to be encapsulated
 * @returns a capsule_t * with command field set to ENC_META_DATA stating
 *          that the data field is of type meta_data_t *.
 */
extern capsule_t *encapsulate_meta_data_t(gint command, meta_data_t *meta);


/**
 * Function that encapsulate an END command.
 * @returns a capsule_t * with command field set to ENC_END stating
 *          that this is the end my friend (some famous song) !
 */
extern capsule_t *encapsulate_end(void);


/**
 * This function returns the MESSAGE_ID from msg_id JSON field
 * @param json_str : a gchar * containing the JSON formated string.
 * @returns a gint that correspond to the msg_id field found in json_str.
 *          If the field is not found it returns ENC_NOT_FOUND. This field
 *          is based on ENC_* constants that are also used for the
 *          communication between threads in client
 */
extern gint get_json_message_id(gchar *json_str);


/**
 * Gets the version of a version json string as returned by serveur's
 * server.
 * @param json_str : a gchar * containing the JSON formated string.
 * @returns version string or NULL
 */
extern gchar *get_json_version(gchar *json_str);


/**
 * Converts to a json gchar * string. Used only by serveur's program
 * @param name : name of the program of which we want to print the version.
 * @param date : publication date of this version
 * @param version : version of the program.
 * @param authors : authors that contributed to this program
 * @param license : license in use for this program and its sources
 * @returns a newlly allocated gchar * string in json format that can be
 *          freed when no longer needed.
 */
extern gchar *convert_version_to_json(gchar *name, gchar *date, gchar *version, gchar *authors, gchar *license);
#endif /* #ifndef _PACKING_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    clock.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file clock.h
 *
 * This file contains all the definitions needed to measure time.
 */
#ifndef _CLOCK_H_
#define _CLOCK_H_

/**
 * @struct a_clock_t
 * @brief Structure to store clock information in order to measure
 *        elapsed time.
 */
typedef struct
{
    GDateTime *begin;  /** begin is filled when initializing the structure */
    GDateTime *end;    /** end is filled when freeing the structure */
} a_clock_t;


/**
 * Creates a new a_clock_t structure filled accordingly
 * @returns a a_clock_t * structure with begin field set.
 */
a_clock_t *new_clock_t(void);


/**
 * Ends the clock and prints the elapsed time and then frees everything
 * @param my_clock is a a_clock_t * structure with begin already filled
 * @param message is a message that we want to include into the displayed
 *        result in order to know what was measured.
 */
extern void end_clock(a_clock_t *my_clock, gchar *message);


#endif /* #ifndef _CLOCK_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    libsauvegarde.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file libsauvegarde.h
 *
 *  This file contains all the definitions for the common tools of
 * "Sauvegarde" collection programs.
 */
#ifndef _LIBSAUVEGARDE_H_
#define _LIBSAUVEGARDE_H_

/* Configuration from ./configure script */
#include "config.h"

#define MHD_PLATFORM_H
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdint.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <errno.h>
#include <microhttpd.h>
#include <glib.h>
#include <gio/gio.h>
#include <glib/gi18n-lib.h>
#include <sqlite3.h>
#include <jansson.h>
#include <curl/curl.h>

#include "configuration.h"
#include "files.h"
#include "hashs.h"
#include "communique.h"
#include "database.h"
#include "packing.h"
#include "query.h"
#include "clock.h"

/**
 * Sets debug_mode on or off if mode is TRUE or FALSE.
 * @param mode a boolean to say whether we want to have debug enabled
 *       (TRUE) or not (FALSE).
 */
extern void set_debug_mode(gboolean mode);


/**
 * Sets the debug mode from command line read option
 * @param debug is a gint read from the command line and should be 0 or 1
 *        but is initialized to something different in order to be able to
 *        detect if the option has been invoked or not.
 */
extern void set_debug_mode_upon_cmdl(gint debug);


/**
 * @returns the debug mode (TRUE if activated and FALSE if not).
 */
extern gboolean get_debug_mode(void);


/**
 * Returns a newly allocated buffer that contains all informations about
 * the version of the libraries we are using.
 * @param name : name of the program of which we want to print the version.
 */
extern gchar *buffer_libraries_versions(gchar *name);

/**
 * Prints version of the libraries we are using.
 * @param name : name of the program of which we want to print the version.
 */
extern void print_libraries_versions(gchar *name);


/**
 * Prints if string is not NULL then prints it to stdout right in the
 * 'description' printf format.
 * @param description is a fprintf format string that must contain a %s
 *        in order to include the string 'string'
 * @param string is the string to be printed.
 */
extern void print_string_option(gchar *description, gchar *string);


/**
 * returns a newly allocated buffer that contains all informations about
 * program's version, authors and license.
 * @param name : name of the program of which we want to print the version.
 * @param date : publication date of this version
 * @param version : version of the program.
 * @param authors : authors that contributed to this program
 * @param license : license in use for this program and its sources
 */
extern gchar *buffer_program_version(gchar *name, gchar *date, gchar *version, gchar *authors, gchar *license);

/**
 * Prints the version of the program.
 * All parameters are of (gchar *) type.
 * @param name : name of the program of which we want to print the version.
 * @param date : publication date of this version
 * @param version : version of the program.
 * @param authors : authors that contributed to this program
 * @param license : license in use for this program and its sources
 */
extern void print_program_version(gchar *name, gchar *date, gchar *version, gchar *authors, gchar *license);


/**
 *  Inits internationalization domain for sauvegarde project
 */
extern void init_international_languages(void);


/**
 * Sets options parameters
 * @param context is the context for options it must have been created
 *        previously and not NULL.
 * @param entries are the entries for the options.
 * @param help is a boolean to choose if we want GOption to display
 *        an automaticaly formatted help.
 * @param bugreport is the message we want to display related to bug
 *        reports. It is displayed at the end of the options help message.
 * @param summary is a gchar* string that will be displayed before the
 *        description of the options. It is supposed to be a summary of
 *        what the program does.
 */
extern void set_option_context_options(GOptionContext *context, GOptionEntry entries[], gboolean help, gchar *bugreport, gchar *summary);


/**
 * Frees a pointer if it is not NULL and returns NULL
 * @param to_free is the pointer to be freed (must have been malloc with
 *         g_malloc* functions).
 * @returns NULL
 */
extern gpointer free_variable(gpointer to_free);


/**
 * Unrefs an object if it is not NULL and returns NULL
 * @param object_to_unref is the pointer to be unref'ed.
 * @returns NULL
 */
extern gpointer free_object(gpointer object_to_unref);


/**
 * Frees an error if it exists and return NULL
 * @param error : the error to be freed
 * @returns NULL
 */
extern gpointer free_error(gpointer error);


/**
 * Frees all elements of a gchar * GSList
 * @param list the list to be freed
 * @returns NULL
 */
extern gpointer free_list(GSList *list);


/**
 * Wrapper for the g_slist_free_full function in order to free lists
 * of gchar *
 * @param data is the pointer to a gchar * string to be freed
 */
extern void free_gchar_variable(gpointer data);


/**
 * Prints a message if the debug flag is set
 * @param format : the format of the message (as in printf)
 * @param ... : va_list of variable that are to be printed into format.
 */
extern void print_debug(const char *format, ...);


/**
 * Prints an error message
 * @param char *filename
 * @param int lineno
 * @param format : the format of the message (as in printf)
 * @param ... : va_list of variable that are to be printed into format.
 */
extern void print_error(char *filename, int lineno, const char *format, ...);


#if !GLIB_CHECK_VERSION(2, 31, 0)
/**
 * defines a wrapper to the g_thread_create function used in glib before
 * 2.31
 */
extern GThread *g_thread_new(const gchar *unused, GThreadFunc func, gpointer data);
#endif


/**
 * Tries to create a directory
 * @param directory is the gchar * string that contains a directory name
 *        to be created (does nothing if it exists).
 */
extern void create_directory(gchar *directory);


/**
 * A signal handler for SIGPIPE (needed by libmicrohttpd in order to be
 * portable.
 */
extern void ignore_sigpipe(void);


/**
 * Waits a number of micro seconds until the number of element in the
 * queue is less than the specified number.
 * @param queue : the queue to be tested
 * @param nbelem : maximum number of element before waiting
 * @param usecs : number of micro seconds to wait
 */
extern void wait_for_queue_to_flush(GAsyncQueue *queue, guint nbelem, useconds_t usecs);


/**
 * @returns a newlly allocated gchar containing MHD version number with
 *          the following format : major.minor.maint-build. It may me freed
 *          when no longer needed.
 */
extern gchar *make_MHD_version(void);


#endif /* #ifndef _LIBSAUVEGARDE_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    configuration.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file configuration.c
 * This file contains the functions to deal with the configuration file
 * of the "Sauvegarde" programs.
 */

#include "libsauvegarde.h"

/**
 * Gets the probable filename for the configuration file of sauvegarde
 * project. This is needed when one wants to install the project in an
 * uncommon location such as a homedir for instance.
 * @param progname is the name of the program we want to search for in the
 *        user's path
 * @param default configuration file name that should be a const string.
 * @returns a gchar * which contain the filename of the configuration file
 *          relative to progname or NULL if something went wrong.
 */
gchar *get_probable_etc_path(gchar *progname, const gchar *configfile)
{
    gchar *abs_path = NULL;
    gchar *path = NULL;

    if (progname != NULL && configfile != NULL)
        {
            /* the first location of the program in the path */
            abs_path = g_find_program_in_path(progname);
            if (abs_path != NULL)
                {
                    path =  g_build_path(G_DIR_SEPARATOR_S, g_path_get_dirname(abs_path), "..", "etc", "sauvegarde", configfile, NULL);
                    free_variable(abs_path);
                }
        }

    return path;
}


/**
 * Reads a string from keyname key in the group grouname from keyfile file
 * and displays errormsg in case of an error
 * @param keyfile : the opened keyfile to read from
 * @param filename : the filename of the keyfile file
 * @param groupname : the groupname where to look for the key
 * @param keyname : the key to read the string from
 * @param errormsg : the error message to be displayed in case of an error
 * @returns the string read at the keyname in the groupname of keyfile
 *          file.
 */
gchar *read_string_from_file(GKeyFile *keyfile, gchar *filename, gchar *groupname, gchar *keyname, gchar *errormsg)
{
    gchar *a_string = NULL;   /** the string to be read */
    GError *error = NULL;     /** Glib error handling   */

     if (g_key_file_has_key(keyfile, groupname, keyname, &error) == TRUE)
        {

            a_string = g_key_file_get_string(keyfile, groupname, keyname, &error);

            if (error != NULL)
                {
                    print_error(__FILE__, __LINE__,  "%s %s : %s", errormsg, filename, error->message);
                    error = free_error(error);
                }
        }
    else if (error != NULL)
        {
            print_error(__FILE__, __LINE__, _("Error while looking for %s key in configuration file : %s\n"), keyname, error->message);
            error = free_error(error);
        }

    return a_string;
}


/**
 * Reads a gint64 from keyname key in the group grouname from keyfile file
 * and displays errormsg in case of an error
 * @param keyfile : the opened keyfile to read from
 * @param filename : the filename of the keyfile file
 * @param groupname : the groupname where to look for the key
 * @param keyname : the key to read the gint64 from
 * @param errormsg : the error message to be displayed in case of an error
 * @returns the gint64 read at the keyname in the groupname of keyfile
 *          file or 0;
 */
gint64 read_int64_from_file(GKeyFile *keyfile, gchar *filename, gchar *groupname, gchar *keyname, gchar *errormsg)
{
    gint64 num = 0;        /** Number to be read     */
    GError *error = NULL;  /** Glib error handling   */

     if (g_key_file_has_key(keyfile, groupname, keyname, &error) == TRUE)
        {
            num =  g_key_file_get_int64(keyfile, groupname, keyname, &error);

            if (error != NULL)
                {
                    print_error(__FILE__, __LINE__, "%s %s : %s", errormsg, filename, error->message);
                    error = free_error(error);
                }
        }
    else if (error != NULL)
        {
            print_error(__FILE__, __LINE__, _("Error while looking for %s key in configuration file : %s\n"), keyname, error->message);
            error = free_error(error);
        }

    return num;
}


/**
 * Reads an integer from keyname key in the group grouname from keyfile file
 * and displays errormsg in case of an error
 * @param keyfile : the opened keyfile to read from
 * @param filename : the filename of the keyfile file
 * @param groupname : the groupname where to look for the key
 * @param keyname : the key to read the gint from
 * @param errormsg : the error message to be displayed in case of an error
 * @returns the gint read at the keyname in the groupname of keyfile
 *          file or 0;
 */
gint read_int_from_file(GKeyFile *keyfile, gchar *filename, gchar *groupname, gchar *keyname, gchar *errormsg)
{
    gint num = 0;          /** Number to be read     */
    GError *error = NULL;  /** Glib error handling   */

    if (g_key_file_has_key(keyfile, groupname, keyname, &error) == TRUE)
        {
            num =  g_key_file_get_integer(keyfile, groupname, keyname, &error);

            if (error != NULL)
                {
                    print_error(__FILE__, __LINE__, "%s %s : %s", errormsg, filename, error->message);
                    error = free_error(error);
                }
        }
    else if (error != NULL)
        {
            print_error(__FILE__, __LINE__,  _("Error while looking for %s key in configuration file : %s\n"), keyname, error->message);
            error = free_error(error);
        }

    return num;
}


/**
 * Reads an integer from keyname key in the group grouname from keyfile file
 * and displays errormsg in case of an error
 * @param keyfile : the opened keyfile to read from
 * @param filename : the filename of the keyfile file
 * @param groupname : the groupname where to look for the key
 * @param keyname : the key to read the gboolean from
 * @param errormsg : the error message to be displayed in case of an error
 * @returns the boolean read at the keyname in the groupname of keyfile
 *          file or FALSE;
 */
gboolean read_boolean_from_file(GKeyFile *keyfile, gchar *filename, gchar *groupname, gchar *keyname, gchar *errormsg)
{
    gboolean bool = FALSE; /** Boolean to be read    */
    GError *error = NULL;  /** Glib error handling   */

    if (g_key_file_has_key(keyfile, groupname, keyname, &error) == TRUE)
        {
            bool =  g_key_file_get_boolean(keyfile, groupname, keyname, &error);

            if (error != NULL)
                {
                    print_error(__FILE__, __LINE__, "%s %s : %s", errormsg, filename, error->message);
                    error = free_error(error);
                }
        }
    else if (error != NULL)
        {
            print_error(__FILE__, __LINE__,  _("Error while looking for %s key in configuration file : %s\n"), keyname, error->message);
            error = free_error(error);
        }

    return bool;
}


/**
 * This functions converts a gchar ** array to a GSList of gchar *.
 * The function appends to the list first_list (if it exists - it may be
 * NULL) each entry of the array so elements are in the same order in the
 * array and in the list.
 * @param array is a gchar * array.
 * @param first_list is a list that may already contain some elements and
 *        to which we will add all the elements of 'array' array.
 * @returns a newly allocated GSList that may be freed when no longer
 *          needed or NULL if array is NULL.
 */
GSList *convert_gchar_array_to_GSList(gchar **array, GSList *first_list)
{
    gchar *a_string = NULL;    /** gchar * that is read in the array      */
    GSList *list = first_list; /** The list to be returned (may be NULL)  */
    gint i = 0;
    gint num = 0;              /** Number of elements in the array if any */

    if (array != NULL)
        {
            num = g_strv_length(array);

            for (i = 0; i < num; i++)
                {
                    a_string = g_strdup(array[i]);
                    list = g_slist_append(list, a_string);

                    print_debug("%s\n", a_string);
                }
        }

    return list;
}


/**
 * Reads a list of gchar * from keyname key in the group grouname from
 * keyfile file and displays errormsg in case of an error
 * @param keyfile : the opened keyfile to read from
 * @param filename : the filename of the keyfile file
 * @param groupname : the groupname where to look for the key
 * @param keyname : the key to read the list of gchar * from
 * @param errormsg : the error message to be displayed in case of an error
 * @returns the list of gchar * read at the keyname in the groupname of
 *          keyfile file or NULL;
 */
GSList *read_list_from_file(GKeyFile *keyfile, gchar *filename, gchar *groupname, gchar *keyname, gchar *errormsg)
{
    GSList *a_list = NULL;         /** list to be returned                                */
    GError *error = NULL;          /** Glib error handling                                */
    gchar **dirname_array = NULL;  /** array of dirnames read into the configuration file */


    if (g_key_file_has_key(keyfile, groupname, keyname, &error) == TRUE)
        {
            dirname_array = g_key_file_get_string_list(keyfile, groupname, keyname, NULL, &error);

            if (dirname_array != NULL)
                {
                    a_list = convert_gchar_array_to_GSList(dirname_array, a_list);
                    /* The array is no longer needed (everything has been copied with g_strdup) */
                    g_strfreev(dirname_array);
                }
            else if (error != NULL)
                {
                    print_error(__FILE__, __LINE__, _("%s %s : %s\n"), errormsg, filename, error->message);
                    error = free_error(error);
                }
        }
    else if (error != NULL)
        {
            print_error(__FILE__, __LINE__, _("Error while looking for %s key in configuration file : %s\n"), keyname, error->message);
            error = free_error(error);
        }

    return a_list;
}




/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    files.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file files.h
 *
 *  This file contains all the definitions for the part that deals with
 *  files of "Sauvegarde" collection programs.
 */
#ifndef _FILES_H_
#define _FILES_H_

/**
 * @struct meta_data_t
 * @brief Stores file's meta datas.
 *
 * Structure to store all meta data associated with a file or a directory
 * command line. We want to limit memory consumption and thus we use the
 * guint instead of gchar *.
 */
typedef struct
{
    guint64 inode;          /**< file's inode.                                                                    */
    guint8 file_type;       /**< type of the file : FILE, DIR, SYMLINK...                                         */
    guint32 mode;           /**< UNIX mode of the file : contains rights for the file                             */
    guint64 atime;          /**< access time                                                                      */
    guint64 ctime;          /**< changed time                                                                     */
    guint64 mtime;          /**< modified time                                                                    */
    guint64 size;           /**< size of the file                                                                 */
    gchar *owner;           /**< owner for the file ie root, apache, dup...                                       */
    gchar *group;           /**< group for the file ie root, apache, admin...                                     */
    guint32 uid;            /**< uid (owner)                                                                      */
    guint32 gid;            /**< gid (group owner)                                                                */
    gchar *name;            /**< name for the file or the directory                                               */
    gchar *link;            /**< link name where points the LINK if file_type is a link                           */
    GSList *hash_data_list; /**< List of hash_data_t structures of the file (hash and datas are in a binary form) */
    gboolean in_cache;      /**< in_cache is a boolean that may be TRUE if the file is in the local cache (client)*/
} meta_data_t;


/**
 * @struct serveur_meta_data_t
 * @brief This structure contains a meta_data_t * field with all
 *        informations about a file's metadata and a hostname field that
 *        says from which machine the file comes from.
 */
typedef struct
{
    gchar *hostname;    /**< machine's hostname from which comes the metadata below */
    meta_data_t *meta;  /**< metadata of a file of the 'hostname' machine           */
} serveur_meta_data_t;


/**
 * Gets the filename of a  GFile
 * @param a_file : the GFile to get the filename from.
 * @returns the name of the GFile if any or "--" gchar * string that may be
 *          freed when no longer needed
 */
extern gchar *get_filename_from_gfile(GFile *a_file);


/**
 * Returns the inode of the file fileinfo
 * @param fileinfo : a GFileInfo pointer obtained from an opened file
 *                   (GFile *)
 * @param[out] meta : meta_data_t * structure that contains all meta data
 *                    for the corresponding file (populated here with
 *                    inode number.
 * @returns the inode file.
 */
extern guint64 get_inode_from_gfile(GFileInfo *fileinfo, meta_data_t *meta);


/**
 * Returns the username of the owner of the a file
 * @param fileinfo : a GFileInfo pointer obtained from an opened file
 *        (GFile *)
 * @param meta : meta_data_t * structure that contains all meta data for
 *        the corresponding file.
 * @returns the "user:group uid:gid" of the file or an empty string if an
 *          error occurs
 */
extern gchar *get_username_owner_from_gfile(GFileInfo *fileinfo, meta_data_t *meta);


/**
 * Returns the dates of a file
 * @param fileinfo : a GFileInfo pointer obtained from an opened file
 *        (GFile *)
 * @param meta : meta_data_t * structure that contains all meta data for
 *        the corresponding file.
 * @returns "access_time changed_time created_time" gchar *string
 */
extern gchar *get_dates_from_gfile(GFileInfo *fileinfo, meta_data_t *meta);


/**
 * sets the dates to a file
 * @param fileinfo : a GFileInfo pointer obtained from an opened file
 *        (GFile *)
 * @param meta : meta_data_t * structure that contains all meta data for
 *        to set to the corresponding file.
 */
extern void set_dates_to_gfile(GFileInfo *fileinfo, meta_data_t *meta);


/**
 * Get unix mode of a file
 * @param fileinfo : a GFileInfo pointer obtained from an opened file
 *        (GFile *)
 * @param meta : meta_data_t * structure that contains all meta data for
 *        the corresponding file.
 * @returns a newly allocated string with file mode in decimal
 *          representation.
 */
extern gchar *get_file_mode_from_gfile(GFileInfo *fileinfo, meta_data_t *meta);


/**
 * Set unix mode of a file
 * @param fileinfo : a GFileInfo pointer obtained from an opened file
 *        (GFile *)
 * @param meta : meta_data_t * structure that contains all meta data for
 *        the corresponding file.
 */
extern void set_file_mode_to_gfile(GFileInfo *fileinfo, meta_data_t *meta);



/**
 * Gets the size of a file
 * @param fileinfo : a GFileInfo pointer obtained from an opened file
 *        (GFile *)
 * @param meta : meta_data_t * structure that contains all meta data for
 *        the corresponding file.
 * @returns a newly allocated string with file size in decimal
 *          representation.
 */
extern gchar *get_file_size_from_gfile(GFileInfo *fileinfo, meta_data_t *meta);


/**
 * Returns the file size from a GFile * file
 * @param file is the GFile from which we want the size.
 * @returns a guint64 that represents the file size or 0.
 */
extern guint64 get_file_size(GFile *file);


/**
 * @returns a newly allocated meta_data_t * empty structure. We use 65534
 * as default uid and gid to avoid using 0 which is dedicated to a
 * priviledged user.
 */
extern meta_data_t *new_meta_data_t(void);


/**
 * @returns a newly allocated serveur_meta_data_t * empty structure.
 */
extern serveur_meta_data_t *new_smeta_data_t(void);


/**
 * Frees the meta_data_t * structure
 * @param meta is a meta_data_t * structure to be freed
 * @returns always NULL
 */
extern gpointer free_meta_data_t(meta_data_t *meta);


/**
 * Frees the serveur_meta_data_t * structure
 * @param smeta is a meta_data_t * structure to be freed
 * @returns always NULL
 */
extern gpointer free_smeta_data_t(serveur_meta_data_t *smeta);


/**
 * Wrapper for the g_slist_free_full function
 * the pointer to the data to be freed
 * @param the pointer to the data to be freed by free_smeta_data_t call.
 */
extern void gslist_free_smeta(gpointer data);


/**
 * Checks if a filename exists or not.
 * @param filename that we want to check.
 * @returns TRUE if filename exists and FALSE if not.
 */
extern gboolean file_exists(gchar *filename);


/**
 * Comparison function to be used when sorting filenames
 * @param a filename a
 * @param b filename b to be compared with a
 * @returns a negative integer if the a comes before b, 0 if they are
 *          equal, or a positive integer if the a comes after b.
 */
extern gint compare_filenames(gconstpointer a, gconstpointer b);


/**
 * Prints a file ands its meta data to the screen
 * @param smeta is the serveur meta data of the file to be printed on the
 *        screen
 */
extern void print_smeta_to_screen(serveur_meta_data_t *smeta);


/**
 * Sets file attributes
 * @param file is a GFile pointer and must not be null
 * @param meta is the structure that contains all meta datas for the
 *        file that we want to set.
 */
extern void set_file_attributes(GFile *file, meta_data_t *meta);


/**
 * Makes a symbolic link named  with 'file' filename that points to the
 * target 'points_to'
 * @param file is the file to create as a symbolic link
 * @param points_to is the target of the link
 */
extern void make_symbolic_link(GFile *file, gchar *points_to);
#endif /* #ifndef _FILES_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    unpacking.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file unpacking.c
 * This file contains the functions to unpack messages for all the
 * programs of "Sauvegarde" project.
 */

#include "libsauvegarde.h"

static guint8 get_guint8_from_json_root(json_t *root, gchar *keyname);
static guint32 get_guint32_from_json_root(json_t *root, gchar *keyname);
static guint64 get_guint64_from_json_root(json_t *root, gchar *keyname);

/**
 * gets a json_t *value into the json_t *root array.
 * @param[in,out] root is the root that contains all meta data values
 * @param keyname is the keyname associated with the value that we want to
 *        get back.
 * @returns the json_t "encoded" value from key keyname from the root
 */
json_t *get_json_value_from_json_root(json_t *root, gchar *keyname)
{
    json_t *value = NULL;

    if (root != NULL && keyname != NULL)
        {
            value = json_object_get(root, keyname);

            if (value == NULL)
                {
                    print_error(__FILE__, __LINE__, _("Error while converting to JSON from keyname %s\n"), keyname);
                    /* exit(EXIT_FAILURE); *//* An error here means that we will do nothing good */
                }
        }

    return value;
}


/**
 * returns the string with key keyname from the json tree root. It is used
 * by serveur to get the hostname from the json received message.
 * @note Freeing json_t *str here is a bad idea as it will free it into
 *       json_t *root variable that is freed afterwards.
 * @param[in,out] root is the main json tree
 * @param keyname is the key for which we seek the string value.
 * @returns a newlly allocated gchar * string that is the value associated
 *          with key keyname. It can be freed with free_variable() when no longer
 *          needed.
 */
gchar *get_string_from_json_root(json_t *root, gchar *keyname)
{
    json_t *str = NULL;
    gchar *a_string = NULL;

    if (root != NULL && keyname != NULL)
        {
            str = get_json_value_from_json_root(root, keyname);
            a_string = g_strdup(json_string_value(str));
        }

    return a_string;
}


/**
 * returns the guint8 value associated with key keyname from the json tree
 * root.
 * @note Freeing json_t *value here is a bad idea as it will free it into
 *       json_t *root variable that is freed afterwards.
 * @param[in,out] root is the main json tree
 * @param keyname is the key for which we seek the guint8 value.
 * @returns a guint8 number that is the value associated with key keyname.
 */
static guint8 get_guint8_from_json_root(json_t *root, gchar *keyname)
{
    json_t *value = NULL;
    guint8 number = 0;

    if (root != NULL && keyname != NULL)
        {
            value = get_json_value_from_json_root(root, keyname);
            number = (guint8) json_integer_value(value);
        }

    return number;
}


/**
 * returns the guint32 value associated with key keyname from the json tree
 * root.
 * @note Freeing json_t *value here is a bad idea as it will free it into
 *       json_t *root variable that is freed afterwards.
 * @param[in,out] root is the main json tree
 * @param keyname is the key for which we seek the guint32 value.
 * @returns a guint32 number that is the value associated with key keyname.
 */
static guint32 get_guint32_from_json_root(json_t *root, gchar *keyname)
{
    json_t *value = NULL;
    guint32 number = 0;

    if (root != NULL && keyname != NULL)
        {
            value = get_json_value_from_json_root(root, keyname);
            number = (guint32) json_integer_value(value);
        }

    return number;
}


/**
 * returns the guint64 value associated with key keyname from the json tree
 * root.
 * @note Freeing json_t *value here is a bad idea as it will free it into
 *       json_t *root variable that is freed afterwards.
 * @param[in,out] root is the main json tree
 * @param keyname is the key for which we seek the guint64 value.
 * @returns a guint64 number that is the value associated with key keyname.
 */
static guint64 get_guint64_from_json_root(json_t *root, gchar *keyname)
{
    json_t *value = NULL;
    guint64 number = 0;

    if (root != NULL && keyname != NULL)
        {
            value = get_json_value_from_json_root(root, keyname);
            number = (guint64) json_integer_value(value);
        }

    return number;
}


/**
 * This function loads a JSON string into a json_t struture
 * @param json_str is the json string
 * @returns a pointer to a filled json_t * structure or NULL upon error
 */
json_t *load_json(gchar *json_str)
{
    json_t *root = NULL;   /** json_t *root is the json tree where we will extract things */
    json_error_t error;    /** json_error_t *error handle json errors if any.             */

    if (json_str != NULL)
        {
            root = json_loads(json_str, 0, &error);

            if (root == NULL)
                {
                     print_error(__FILE__, __LINE__, _("Error while trying to load JSON : %s\nline: %d, column: %d, position: %d, string: %s\n"), error.text, error.line, error.column, error.position, json_str);
                }
        }

    return root;
}


/**
 * This function returns the MESSAGE_ID from msg_id JSON field
 * @param json_str : a gchar * containing the JSON formated string.
 * @returns a gint that correspond to the msg_id field found in json_str.
 *          If the field is not found it returns ENC_NOT_FOUND. This field
 *          is based on ENC_* constants that are also used for the
 *          communication between threads in client
 */
gint get_json_message_id(gchar *json_str)
{
    json_t *root = NULL;           /** json_t *root is the json tree from which we will extract msg_id                   */
    gint msg_id = ENC_NOT_FOUND;   /** gint msg_id is the message id from the JSON string by default it is ENC_NOT_FOUND */

    if (json_str != NULL)
        {
            root = load_json(json_str);

            if (root != NULL)
                {
                    msg_id = get_guint8_from_json_root(root, "msg_id");

                    json_decref(root);
                }
        }

    return msg_id;
}


/**
 * Gets the version of a version json string as returned by serveur's
 * server.
 * @param json_str : a gchar * containing the JSON formated string.
 * @returns version string or NULL
 */
gchar *get_json_version(gchar *json_str)
{
    json_t *root = NULL;     /** json_t *root is the json tree from which we will extract version's string */
    gchar *version = NULL;   /** version'string has extracted or NULL                                      */

    if (json_str != NULL)
        {
            root = load_json(json_str);

            if (root != NULL)
                {
                    version = get_string_from_json_root(root, "version");

                    json_decref(root);
                }
        }

    return version;
}


/**
 * This function returns a list of hash_data_t * from an json array
 * @param root is the root json string that may contain an array named "name"
 * @param name is the name of the array to look for into
 * @returns a GSList that me be composed of 0 element (ie NULL). Elements
 *          are of type hash_data_t *.
 */
GSList *extract_gslist_from_array(json_t *root, gchar *name)
{
    json_t *array =  NULL;   /** json_t *array is the retrieved array used to iter over to fill the list     */
    size_t index = 0;        /** size_t index is the iterator to iter over the array                         */
    json_t *value = NULL;    /** json_t *value : value = array[index] when iterating with json_array_foreach */
    GSList *head = NULL;     /** GSList *head the list to build and iclude into meta_data_t *meta            */
    guchar *a_hash = NULL;   /** guchar *a_hash is one base64 decoded hash (binary format)                   */
    gsize hash_len = 0;      /** gsize hash_len is the length of the decoded hash (must alwas be HASH_LEN)   */
    hash_data_t *hash_data = NULL;

    if (root != NULL && name != NULL)
        {

            /* creating a list with the json array found in root json string */
            array = get_json_value_from_json_root(root, name);

            /**
             * @note : This is a loop from jansson library for the array.
             *         One needs at least jansson 2.5 to compile this.
             */
            json_array_foreach(array, index, value)
                {
                    a_hash = g_base64_decode(json_string_value(value), &hash_len);
                    hash_data = new_hash_data_t(NULL, 0, a_hash);

                    head = g_slist_prepend(head, hash_data);
                }

            head = g_slist_reverse(head);
        }

    return head;
}


/**
 * Fills a serveur_meta_data_t from datas that are in json_t *root
 * @param root is the JSON string that should contain all datas needed
 *        to fill the serveur_meta_data_t * structure.
 * @returns a newly allocated serveur_meta_data_t * structure filled
 *          accordingly.
 */
static serveur_meta_data_t *fills_serveur_meta_data_t_from_json_t(json_t *root)
{
    meta_data_t *meta = NULL;          /** meta_data_t *meta will be returned in smeta and contain file's metadata     */
    serveur_meta_data_t *smeta = NULL; /** serveur_meta_data_t *smeta will be returned at the end                      */

    if (root != NULL)
        {
            smeta = new_smeta_data_t();
            meta = new_meta_data_t();

            meta->file_type = get_guint8_from_json_root(root, "filetype");
            meta->mode = get_guint32_from_json_root(root, "mode");

            meta->atime = get_guint64_from_json_root(root, "atime");
            meta->ctime = get_guint64_from_json_root(root, "ctime");
            meta->mtime = get_guint64_from_json_root(root, "mtime");
            meta->size  = get_guint64_from_json_root(root, "fsize");
            meta->inode = get_guint64_from_json_root(root, "inode");

            meta->owner = get_string_from_json_root(root, "owner");
            meta->group = get_string_from_json_root(root, "group");

            meta->uid = get_guint32_from_json_root(root, "uid");
            meta->gid = get_guint32_from_json_root(root, "gid");

            meta->name = get_string_from_json_root(root, "name");
            meta->link = get_string_from_json_root(root, "link");

            meta->hash_data_list = extract_gslist_from_array(root, "hash_list");

            smeta->meta = meta;
            smeta->hostname =  get_string_from_json_root(root, "hostname");
        }

    return smeta;
}


/**
 * This function returns a list from an json array.
 * @param root is the root json string that must contain an array named
 *        "file_list"
 * @returns a GSList that may be composed of 0 element (ie NULL). Elements
 *          are of type serveur_meta_data_t *.
 */
GSList *extract_smeta_gslist_from_file_list(json_t *root)
{
    json_t *array =  NULL;   /** json_t *array is the retrieved array used to iter over to fill the list     */
    size_t index = 0;        /** size_t index is the iterator to iter over the array                         */
    json_t *value = NULL;    /** json_t *value : value = array[index] when iterating with json_array_foreach */
    GSList *head = NULL;     /** GSList *head the list to build and iclude into meta_data_t *meta            */
    serveur_meta_data_t *smeta = NULL; /** serveur_meta_data_t *smeta will be returned at the end                      */

    if (root != NULL)
        {

            /* creating a list with the json array found in root json string */
            array = get_json_value_from_json_root(root, "file_list");

            /**
             * @note : This is a loop from jansson library for the array.
             *         One needs at least jansson 2.5 to compile this.
             */
            json_array_foreach(array, index, value)
                {
                    smeta = fills_serveur_meta_data_t_from_json_t(value);
                    head = g_slist_prepend(head, smeta);
                }
        }

    return head;
}


/**
 * Function that converts json_str containing the keys "hash", "data"
 * and "read" into hash_data_t structure.
 * @param json_str is a json string containing the keys "hash", "data"
 *        and read
 * @returns a newly allocated hash_data_t structure with the
 *          corresponding datas in it.
 */
hash_data_t *convert_json_to_hash_data(gchar *json_str)
 {
    json_t *root = NULL;
    guchar *data = NULL;
    guint8 *hash = NULL;
    gchar *string = NULL;
    gsize data_len = 0;
    gsize hash_len = 0;
    gssize read = 0;
    hash_data_t *hash_data = NULL;

    if (json_str != NULL)
        {
            root = load_json(json_str);

            if (root != NULL)
                {
                    string = get_string_from_json_root(root, "data");
                    data = (guchar *) g_base64_decode(string, &data_len);
                    free_variable(string);

                    string = get_string_from_json_root(root, "hash");
                    hash = (guint8 *) g_base64_decode(string, &hash_len);
                    free_variable(string);

                    read = get_guint64_from_json_root(root, "size");

                    /* Some basic verifications */
                    if (data_len == read && hash_len == HASH_LEN)
                        {
                            hash_data = new_hash_data_t(data, read, hash);
                        }
                    else
                        {
                            print_error(__FILE__, __LINE__, _("Something is wrong with lengths: data_len = %ld, read = %ld, hash_len = %ld, HASH_LEN = %ld\n"), data_len, read, hash_len, HASH_LEN);
                        }

                    json_decref(root);
                }
        }

    return hash_data;
 }



/**
 * This function should return a newly allocated serveur_meta_data_t *
 * structure with all informations included from the json string.
 * @param json_str is a gchar * containing the JSON formated string.
 * @returns a newly_allocated serveur_meta_data_t * structure that can be
 *          freed when no longer needed with free_smeta_data_t() function.
 *          This function can return NULL if json_str is NULL itself.
 */
serveur_meta_data_t *convert_json_to_smeta_data(gchar *json_str)
{
    json_t *root = NULL;                 /** json_t *root is the json tree from which we will extract everything         */
    serveur_meta_data_t *smeta = NULL;   /** serveur_meta_data_t *smeta will be returned at the end                      */

    /**
     * @todo : validate that we have a json string and make
     *         sure that this is a meta_data one.
     */

    if (json_str != NULL)
        {

            root = load_json(json_str);

            if (root != NULL)
                {
                    smeta = fills_serveur_meta_data_t_from_json_t(root);

                    json_decref(root);
                }
        }

    return smeta;
}
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    hashs.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file hashs.h
 *
 * This file contains all the definitions of the functions and structures
 * that are used to deal with hashs in all Sauvegarde's project.
 */
#ifndef _HASHS_H_
#define _HASHS_H_

/**
 * @def HASH_LEN
 * Defines the length in byte of hash's binary form
 */
#define HASH_LEN (32)


/**
 * @struct data_t
 * @brief Structure that stores buffer data (buffer) and its size (read).
 *
 * It will be associated with the checksum into the GTree balanced binary
 * tree of the hashs_t structure.
 */
typedef struct
{
    guchar *buffer;      /**< buffer data read from the file              */
    gssize read;         /**< size of that buffer                         */
    gboolean into_cache; /**< TRUE if it has been inserted into the cache */
} data_t;


/**
 * @struct hash_data_t
 * @brief Structure to store a hash and the corresponding datas
 */
typedef struct
{
    guint8 *hash;
    guchar *data;
    gssize read;
} hash_data_t;


/**
 * Comparison function used with the GTree structure to sort hashs
 * properly.
 * @returns a negative value if a < b, zero if a = b and a positive value
 * if a > b.
 */
extern gint compare_two_hashs(gconstpointer a, gconstpointer b);


/**
 * Transforms a binary hashs into a printable string (gchar *)
 * @param a_hash is a hash in a binary form that we want to transform into
 *        a string.
 * @returns a string that contains the hash in an hexadecimal form.
 */
extern gchar *hash_to_string(guint8 *a_hash);


/**
 * Transforms a binary hashs into a printable string (gchar *)
 * @param str_hash a string (gchar *) that conatins the hash in an
 *        hexadecimal form.
 * @returns a hash in a binary form (guint8 *).
 */
extern guint8 *string_to_hash(gchar *str_hash);


/**
 * Creates a new data_t * structure populated with the buffer and its size.
 * @param buffer : the data to be stored
 * @param read : the size of that buffer
 * @param into_cache : says wether it is already into the cache (TRUE) or
 *        not (FALSE)
 * @returns a newly allocated data_t * structure that can be freed when no
 *         longer needed.
 */
extern data_t *new_data_t_structure(guchar *buffer, gssize read, gboolean into_cache);


/**
 * Frees data buffer
 * @param a_data : the stucture that contains buffer data and its size to
 * be freed
 */
extern gpointer free_data_t_structure(data_t *a_data);


/**
 * Frees hash_data_t *buffer and returns NULL.
 * @param hash_data : the stucture that contains buffer data, hash data
 * and its size to be freed.
 * @returns always NULL.
 */
extern gpointer free_hash_data_t_structure(hash_data_t *hash_data);


/**
 * handler for g_slist_free_full
 * @param data must be a hash_data_t * structure.
 */
extern void free_hdt_struct(gpointer data);


/**
 * Inits and returns a newly hash_data_t structure.
 * @returns a newly created hash_data_t structure.
 */
extern hash_data_t *new_hash_data_t(guchar * data, gssize read, guint8 *hash);


/**
 * Converts the hash list to a list of comma separated hashs in one gchar *
 * string. Hashs are base64 encoded
 * @param hash_list  GSList of hashs
 * @returns a list of comma separated hashs in one gchar * string.
 */
extern gchar *convert_hash_data_list_to_gchar(GSList *hash_list);


/**
 * Makes a path from a binary hash : 0E/39/AF for level 3 with hash (in hex)
 * begining by 0E39AF.
 * @param path is a gchar * prefix for the path (ie /var/tmp/sauvegarde for
 *        instance).
 * @param hash is a guint8 pointer to the binary representation of a hash.
 * @param level The level we want the path to have. It is an unsigned int
 *        and must be less than HASH_LEN. a level of N gives 2^N
 *        directories. We should add a level when more than 512 files are
 *        in each last subdirectories.
 * @returns a string as a gchar * made of the path and the hex
 *          representation of hash on 'level' levels. With the example above
 *          it will return /var/tmp/sauvegarde/0E/39/AF
 */
extern gchar *make_path_from_hash(gchar *path, guint8 *hash, guint level);


/**
 * makes a GSList of hash_data_t * element where 'hash' field is base64
 * decoded hashs from a string containning base64 * encoded hashs that
 * must be separated by comas.
 * @param the string containing base64 encoded hashs such as : *
 *        "cCoCVkt/AABf04jn2+rfDmqJaln6P2A9uKolBjEFJV4=", "0G8MaPZ/AADNyaPW7ZP2s0BI4hAdZZIE2xO1EwdOzhE="
 *        for instance.
 * @returns a GSList of hash_data_t * where each elements contains a
 *          base64 decoded hash (binary form).
 */
extern GSList *make_hash_data_list_from_string(gchar *hash_string);


#endif /* #ifndef _HASHS_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    libsauvegarde.c
 *
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file libsauvegarde.c
 * This library contains all tools that may be used in at least two of
 * the "Sauvegarde" programs.
 */

#include "libsauvegarde.h"

static void catcher(int sig);
static void print_buffer(gchar *buffer);


/**
 * Initializing debug_mode by default to the compilation choice.
 */
gboolean debug_mode = ENABLE_DEBUG;


/**
 * Sets debug_mode on or off if mode is TRUE or FALSE.
 * @param mode a boolean to say whether we want to have debug enabled
 *       (TRUE) or not (FALSE).
 */
void set_debug_mode(gboolean mode)
{
    if (debug_mode == TRUE && mode == FALSE)
        {
            print_debug(_("Debug mode is disabled.\n"));
        }
    else if (debug_mode == FALSE && mode == TRUE)
        {
            print_debug(_("Debug mode is activated.\n"));
        }

    debug_mode = mode;
}


/**
 * Sets the debug mode from command line read option
 * @param debug is a gint read from the command line and should be 0 or 1
 *        but is initialized to something different in order to be able to
 *        detect if the option has been invoked or not.
 */
void set_debug_mode_upon_cmdl(gint debug)
{
    if (debug == 0)
        {
            set_debug_mode(FALSE);
        }
    else if (debug == 1)
        {
            set_debug_mode(TRUE);
        }
}


/**
 * @returns the debug mode (TRUE if activated and FALSE if not).
 */
gboolean get_debug_mode(void)
{
    return debug_mode;
}


/**
 * Prints the buffer to stdout and free its memory !
 * @param buffer : the buffer to be printed and then freed
 */
static void print_buffer(gchar *buffer)
{
    if (buffer != NULL)
        {
            fprintf(stdout, "%s", buffer);
            buffer = free_variable(buffer);
        }
}


/**
 * @returns a newlly allocated gchar containing MHD version number with
 *          the following format : major.minor.maint-build. It may me freed
 *          when no longer needed.
 */
gchar *make_MHD_version(void)
{
    gint build = 0;
    gint maint = 0;
    gint minor = 0;
    gint major = 0;
    gchar *version = NULL;

    build = ((MHD_VERSION >> 4) & 15) * 10 + (MHD_VERSION & 15);
    maint = ((MHD_VERSION >> 12) & 15) * 10 + ((MHD_VERSION >> 8) & 15);
    minor = ((MHD_VERSION >> 20) & 15) * 10 + ((MHD_VERSION >> 16) & 15);
    major = ((MHD_VERSION >> 28) & 15) * 10 + ((MHD_VERSION >> 24) & 15);

    version = g_strdup_printf("%d.%d.%d-%d", major, minor, maint, build);

    return version;
}


/**
 * Returns a newly allocated buffer that contains all informations about
 * the version of the libraries we are using.
 * @param name : name of the program of which we want to print the version.
 */
gchar *buffer_libraries_versions(gchar *name)
{
    gchar *buffer = NULL;
    gchar *buf1 = NULL;
    gchar *comm_version = NULL;

    if (name != NULL)
        {
            buffer = g_strdup_printf(_("%s was compiled with the following libraries:\n\t. GLIB version : %d.%d.%d\n"), name, glib_major_version, glib_minor_version, glib_micro_version);

            if (g_strcmp0(name, "serveur") == 0)
                {
                    comm_version = make_MHD_version();
                    buf1 = g_strdup_printf("%s\t. LIBMHD : %s\n", buffer, comm_version);
                    buffer = free_variable(buffer);
                    comm_version = free_variable(comm_version);
                }
            else
                {
                    comm_version = get_communication_library_version();

                    if (comm_version != NULL)
                        {
                            buf1 = g_strdup_printf("%s%s", buffer, comm_version);
                            comm_version = free_variable(comm_version);
                            buffer = free_variable(buffer);
                        }
                }

            if (buf1 == NULL && buffer != NULL)
                {
                    buf1 = g_strdup(buffer);
                    buffer = free_variable(buffer);
                }

            buffer = g_strdup_printf(_("%s\t. %s version : %s\n\t. JANSSON version : %d.%d.%d\n"), buf1, DATABASE_NAME, db_version(), JANSSON_MAJOR_VERSION, JANSSON_MINOR_VERSION, JANSSON_MICRO_VERSION);
            buf1 = free_variable(buf1);
        }

    return buffer;
}


/**
 * Prints version of the libraries we are using.
 * @param name : name of the program of which we want to print the version.
 */
void print_libraries_versions(gchar *name)
{
    gchar *buffer = NULL;

    buffer = buffer_libraries_versions(name);
    print_buffer(buffer);
}


/**
 * Prints if string is not NULL then prints it to stdout right in the
 * 'description' printf format.
 * @param description is a fprintf format string that must contain a %s
 *        in order to include the string 'string'
 * @param string is the string to be printed.
 */
void print_string_option(gchar *description, gchar *string)
{
    if (string != NULL)
    {
        fprintf(stdout, description, string);
    }
}


/**
 * Returns a newly allocated buffer that contains all informations about
 * program's version, authors and license.
 * @param name : name of the program of which we want to print the version.
 * @param date : publication date of this version
 * @param version : version of the program.
 * @param authors : authors that contributed to this program
 * @param license : license in use for this program and its sources
 */
gchar *buffer_program_version(gchar *name, gchar *date, gchar *version, gchar *authors, gchar *license)
{
    gchar *buffer = NULL;

        if (name != NULL && date != NULL && version != NULL && authors != NULL && license != NULL)
        {
            buffer = g_strdup_printf(_("%s version : %s-%s (%s)\nAuthor(s) : %s\nLicense : %s\n\n"), name, version, REVISION, date, authors, license);
        }

    return buffer;
}


/**
 * Prints the version of the program.
 * All parameters are of (gchar *) type.
 * @param name : name of the program of which we want to print the version.
 * @param date : publication date of this version
 * @param version : version of the program.
 * @param authors : authors that contributed to this program
 * @param license : license in use for this program and its sources
 */
void print_program_version(gchar *name, gchar *date, gchar *version, gchar *authors, gchar *license)
{
    gchar *buffer = NULL;

    buffer = buffer_program_version(name, date, version, authors, license);
    print_buffer(buffer);
}


/**
 *  Inits internationalization domain for sauvegarde project
 */
void init_international_languages(void)
{
    gchar *result = NULL;
    gchar *codeset = NULL;
    gchar *text_domain = NULL;

    setlocale(LC_ALL, "");
    result = bindtextdomain(GETTEXT_PACKAGE, LOCALE_DIR);
    codeset = bind_textdomain_codeset(GETTEXT_PACKAGE, "UTF-8");
    text_domain = textdomain(GETTEXT_PACKAGE);

    print_debug(_("Debug mode is activated.\n"));
    print_debug(_("Gettext package : %s\n"), GETTEXT_PACKAGE);

    if (result != NULL)
        {
            print_debug(_("Bindtextdomain : %s\n"), result);
        }

    if (codeset != NULL)
        {
            print_debug(_("Code set : %s\n"), codeset);
        }

    if (text_domain != NULL)
        {
            print_debug(_("Text domain : %s\n"), text_domain);
        }
}


/**
 * Sets options parameters
 * @param context is the context for options it must have been created
 *        previously and not NULL.
 * @param entries are the entries for the options.
 * @param help is a boolean to choose if we want GOption to display
 *        an automaticaly formatted help.
 * @param bugreport is the message we want to display related to bug
 *        reports. It is displayed at the end of the options help message.
 * @param summary is a gchar* string that will be displayed before the
 *        description of the options. It is supposed to be a summary of
 *        what the program does.
 */
void set_option_context_options(GOptionContext *context, GOptionEntry entries[], gboolean help, gchar *bugreport, gchar *summary)
{
    if (context != NULL && bugreport != NULL && summary != NULL)
        {
            g_option_context_add_main_entries(context, entries, GETTEXT_PACKAGE);
            g_option_context_set_help_enabled(context, help);
            g_option_context_set_description(context, bugreport);
            g_option_context_set_summary(context, summary);
        }
}


/**
 * Frees a pointer if it is not NULL and returns NULL
 * @param to_free is the pointer to be freed (must have been malloc with
 *         g_malloc* functions).
 * @returns NULL
 */
gpointer free_variable(gpointer to_free)
{
    if (to_free != NULL)
        {
            g_free(to_free);
            to_free = NULL;
        }

    return NULL;
}


/**
 * Wrapper for the g_slist_free_full function in order to free lists
 * of gchar *
 * @param data is the pointer to a gchar * string to be freed
 */
void free_gchar_variable(gpointer data)
{
    free_variable(data);
}


/**
 * Unrefs an object if it is not NULL and returns NULL
 * @param object_to_unref is the pointer to be unref'ed.
 * @returns NULL
 */
gpointer free_object(gpointer object_to_unref)
{
    if (object_to_unref != NULL)
        {
            g_object_unref(object_to_unref);
            object_to_unref = NULL;
        }

    return NULL;
}


/**
 * Frees an error if it exists and return NULL
 * @param error : the error to be freed
 * @returns NULL
 */
gpointer free_error(gpointer error)
{
    if (error != NULL)
        {
            g_error_free(error);
            error = NULL;
        }

    return NULL;
}


/**
 * Frees all elements of a gchar * GSList
 * @param list the list to be freed
 * @returns NULL
 */
gpointer free_list(GSList *list)
{
    g_slist_free_full(list, free_gchar_variable);

    return NULL;
}


/**
 * Prints a message if the debug flag is set
 * @param format : the format of the message (as in printf)
 * @param ... : va_list of variable that are to be printed into format.
 */
void print_debug(const char *format, ...)
{
    va_list ap;

    if (debug_mode == TRUE)
        {
            va_start(ap, format);
            vfprintf(stdout, format, ap);
            va_end(ap);
        }
}


/**
 * Prints an error message
 * @param char *filename
 * @param int lineno
 * @param format : the format of the message (as in printf)
 * @param ... : va_list of variable that are to be printed into format.
 */
void print_error(char *filename, int lineno, const char *format, ...)
{
    va_list ap;


    fprintf(stderr, "[%s, %d] ", filename, lineno);
    va_start(ap, format);
    vfprintf(stderr, format, ap);
    va_end(ap);

}


#if !GLIB_CHECK_VERSION(2, 31, 0)
/**
 * defines a wrapper to the g_thread_create function used in glib before
 * 2.31
 */
GThread *g_thread_new(const gchar *unused, GThreadFunc func, gpointer data)
{
    GThread *thread = g_thread_create(func, data, TRUE, NULL);

    if (thread == NULL)
        {
            g_error(_("g_thread_create failed !"));
        }

    return thread;
}
#endif


/**
 * Tries to create a directory. Does not report an error if the directory
 * already exists.
 * @param directory is the gchar * string that contains a directory name
 *        to be created (does nothing if it exists).
 */
void create_directory(gchar *directory)
{
    GFile *dir = NULL;
    GError *error = NULL;

    if (directory != NULL)
        {
            dir = g_file_new_for_path(directory);
            g_file_make_directory_with_parents(dir, NULL, &error);

            if (error != NULL)
                {
                    if (error->code != G_IO_ERROR_EXISTS)
                        {
                            print_error(__FILE__, __LINE__, ("Failed to create directory %s : %s\n"), directory, error->message);
                        }
                    error = free_error(error);
                }

            dir = free_object(dir);
        }
}


/**
 * A signal catcher that does nothing for SIGPIPE (needed by libmicrohttpd
 * in order to be portable.
 */
static void catcher(int sig)
{
}


/**
 * A signal handler for SIGPIPE (needed by libmicrohttpd in order to be
 * portable).
 */
void ignore_sigpipe(void)
{
    struct sigaction oldsig;
    struct sigaction sig;

    sig.sa_handler = &catcher;
    sigemptyset (&sig.sa_mask);

    #ifdef SA_INTERRUPT
        sig.sa_flags = SA_INTERRUPT;  /* SunOS */
    #else
        sig.sa_flags = SA_RESTART;
    #endif

    if (sigaction(SIGPIPE, &sig, &oldsig) != 0)
        {
            fprintf (stderr, "Failed to install SIGPIPE handler: %s\n", strerror (errno));
        }
}


/**
 * Waits a number of micro seconds until the number of element in the
 * queue is less than the specified number.
 * @param queue : the queue to be tested
 * @param nbelem : maximum number of element before waiting
 * @param usecs : number of micro seconds to wait
 */
void wait_for_queue_to_flush(GAsyncQueue *queue, guint nbelem, useconds_t usecs)
{
    if (queue != NULL && usecs < 1000000)
        {
            /**
             * Checks if the queue length is less than 8 before
             * continuing because we want to be sure that what we
             * provide is processed...
             */
            while (g_async_queue_length(queue) > nbelem)
                {
                    usleep(usecs);
                }
        }
}


/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    files.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file files.c
 * This file contains the functions to deal with files of the "Sauvegarde"
 * collection programs.
 */

#include "libsauvegarde.h"


/**
 * @returns a newly allocated meta_data_t * empty structure. We use 65534
 * as default uid and gid to avoid using 0 which is dedicated to a
 * priviledged user.
 */
meta_data_t *new_meta_data_t(void)
{
    meta_data_t *meta = NULL;

    meta = (meta_data_t *) g_malloc0(sizeof(meta_data_t));

    if (meta != NULL)
        {
            meta->file_type = 0;
            meta->inode = 0;
            meta->mode = 0;
            meta->atime = 0;
            meta->ctime = 0;
            meta->mtime = 0;
            meta->size = 0;
            meta->owner = NULL;
            meta->group = NULL;
            meta->uid = 65534;  /* nfsnobody on my system ie unpriviledged user */
            meta->gid = 65534;  /* nfsnobody on my system ie unpriviledged user */
            meta->name = NULL;
            meta->link = NULL;
            meta->hash_data_list = NULL;
            meta->in_cache = FALSE; /* a newly meta data is not in the local cache ! */
        }

    return meta;
}


/**
 * @returns a newly allocated serveur_meta_data_t * empty structure.
 */
serveur_meta_data_t *new_smeta_data_t(void)
{
    serveur_meta_data_t *smeta = NULL;

    smeta = (serveur_meta_data_t *) g_malloc0(sizeof(serveur_meta_data_t));

    if (smeta != NULL)
        {
            smeta->hostname = NULL;
            smeta->meta = NULL;
        }

    return smeta;
}


/**
 * Frees the meta_data_t * structure
 * @param meta is a meta_data_t * structure to be freed
 * @returns always NULL
 */
gpointer free_meta_data_t(meta_data_t *meta)
{
    if (meta != NULL)
        {
            free_variable(meta->owner);
            free_variable(meta->group);
            free_variable(meta->name);
            /* meta->link should not be freed when in client */
            g_slist_free_full(meta->hash_data_list, free_hdt_struct);
            free_variable(meta);
        }

    return NULL;
}


/**
 * Frees the serveur_meta_data_t * structure
 * @param smeta is a meta_data_t * structure to be freed
 * @returns always NULL
 */
gpointer free_smeta_data_t(serveur_meta_data_t *smeta)
{
    if (smeta != NULL)
        {
            smeta->meta = free_meta_data_t(smeta->meta);
            smeta->hostname = free_variable(smeta->hostname);
            smeta = free_variable(smeta);
        }

    return NULL;
}


/**
 * Wrapper for the g_slist_free_full function
 * the pointer to the data to be freed
 * @param the pointer to the data to be freed by free_smeta_data_t call.
 */
void gslist_free_smeta(gpointer data)
{
    free_smeta_data_t((serveur_meta_data_t *)data);
}


/**
 * Gets the filename of a  GFile
 * @param a_file : the GFile to get the filename from.
 * @returns the name of the GFile if any or "--" gchar * string that may be
 *          freed when no longer needed
 */
gchar *get_filename_from_gfile(GFile *a_file)
{
    gchar *filename = NULL;

    if (a_file != NULL)
        {
            filename = g_file_get_parse_name(a_file);
        }

    return filename;
}


/**
 * Returns the inode of the file fileinfo
 * @param fileinfo : a GFileInfo pointer obtained from an opened file
 *                   (GFile *)
 * @param[out] meta : meta_data_t * structure that contains all meta data
 *                    for the corresponding file (populated here with
 *                    inode number.
 * @returns the inode file.
 */
guint64 get_inode_from_gfile(GFileInfo *fileinfo, meta_data_t *meta)
{
    guint64 inode = 0;


    if (fileinfo != NULL && meta != NULL)
        {
            inode = g_file_info_get_attribute_uint64(fileinfo, G_FILE_ATTRIBUTE_UNIX_INODE);

            meta->inode = inode;
        }

    return inode;
}


/**
 * Returns the username of the owner of the file fileinfo
 * @param fileinfo : a GFileInfo pointer obtained from an opened file
 *                   (GFile *)
 * @param[out] meta : meta_data_t * structure that contains all meta data
 *                    for the corresponding file (populated here with owner,
 *                    group, uid and gid.
 * @returns the "user:group uid:gid" of the file or an empty string if an
 *          error occurs
 */
gchar *get_username_owner_from_gfile(GFileInfo *fileinfo, meta_data_t *meta)
{
    gchar *result = NULL;

    if (fileinfo != NULL && meta != NULL)
        {


            meta->owner = g_file_info_get_attribute_as_string(fileinfo, G_FILE_ATTRIBUTE_OWNER_USER);
            meta->group = g_file_info_get_attribute_as_string(fileinfo, G_FILE_ATTRIBUTE_OWNER_GROUP);

            meta->uid = g_file_info_get_attribute_uint32(fileinfo, G_FILE_ATTRIBUTE_UNIX_UID);
            meta->gid = g_file_info_get_attribute_uint32(fileinfo, G_FILE_ATTRIBUTE_UNIX_GID);

            result = g_strdup_printf("%s:%s %d:%d", meta->owner, meta->group, meta->uid, meta->gid);
        }
    else
        {
            result = g_strdup("");
        }

    return result;
}


/**
 * Returns the dates of a file
 * @param fileinfo : a GFileInfo pointer obtained from an opened file
 *        (GFile *)
 * @param meta : meta_data_t * structure that contains all meta data for
 *        the corresponding file.
 * @returns "access_time changed_time modified_time" gchar *string
 */
gchar *get_dates_from_gfile(GFileInfo *fileinfo, meta_data_t *meta)
{
    gchar *result = NULL;

    if (fileinfo != NULL && meta != NULL)
        {
            meta->atime = g_file_info_get_attribute_uint64(fileinfo, G_FILE_ATTRIBUTE_TIME_ACCESS);
            meta->ctime = g_file_info_get_attribute_uint64(fileinfo, G_FILE_ATTRIBUTE_TIME_CHANGED);
            meta->mtime = g_file_info_get_attribute_uint64(fileinfo, G_FILE_ATTRIBUTE_TIME_MODIFIED);

            result = g_strdup_printf("%" G_GUINT64_FORMAT " %"  G_GUINT64_FORMAT " %"  G_GUINT64_FORMAT "", meta->atime, meta->ctime, meta->mtime);
        }
    else
        {
            result = g_strdup("");
        }

    return result;
}


/**
 * sets the dates to a file
 * @param fileinfo : a GFileInfo pointer obtained from an opened file
 *        (GFile *)
 * @param meta : meta_data_t * structure that contains all meta data for
 *        to set to the corresponding file.
 */
void set_dates_to_gfile(GFileInfo *fileinfo, meta_data_t *meta)
{
    if (fileinfo != NULL && meta != NULL)
        {
            g_file_info_set_attribute_uint64(fileinfo, G_FILE_ATTRIBUTE_TIME_ACCESS, meta->atime);
            g_file_info_set_attribute_uint64(fileinfo, G_FILE_ATTRIBUTE_TIME_CHANGED, meta->ctime);
            g_file_info_set_attribute_uint64(fileinfo, G_FILE_ATTRIBUTE_TIME_MODIFIED, meta->mtime);
        }
}


/**
 * Get unix mode of a file
 * @param fileinfo : a GFileInfo pointer obtained from an opened file
 *        (GFile *)
 * @param meta : meta_data_t * structure that contains all meta data for
 *        the corresponding file.
 * @returns a newly allocated string with file mode in decimal
 *          representation.
 */
gchar *get_file_mode_from_gfile(GFileInfo *fileinfo, meta_data_t *meta)
{
    gchar *result = NULL;

    if (fileinfo != NULL)
        {
            meta->mode = g_file_info_get_attribute_uint32(fileinfo, G_FILE_ATTRIBUTE_UNIX_MODE);

            result =  g_strdup_printf("%d", meta->mode);
        }
    else
        {
            result = g_strdup("");
        }

    return result;
}


/**
 * Set unix mode of a file
 * @param fileinfo : a GFileInfo pointer obtained from an opened file
 *        (GFile *)
 * @param meta : meta_data_t * structure that contains all meta data for
 *        the corresponding file.
 */
void set_file_mode_to_gfile(GFileInfo *fileinfo, meta_data_t *meta)
{
    if (fileinfo != NULL && meta != NULL)
        {
            print_debug(_("Setting mode: %d\n"), meta->mode);
            g_file_info_set_attribute_uint32(fileinfo, G_FILE_ATTRIBUTE_UNIX_MODE, meta->mode);
        }
}


/**
 * Gets the size of a file
 * @param fileinfo : a GFileInfo pointer obtained from an opened file
 *        (GFile *)
 * @param meta : meta_data_t * structure that contains all meta data for
 *        the corresponding file.
 * @returns a newly allocated string with file size in decimal
 *          representation.
 */
gchar *get_file_size_from_gfile(GFileInfo *fileinfo, meta_data_t *meta)
{
    gchar *result = NULL;

    if (fileinfo != NULL)
        {
            meta->size = g_file_info_get_attribute_uint64(fileinfo, G_FILE_ATTRIBUTE_STANDARD_SIZE);

            result = g_strdup_printf("%"  G_GUINT64_FORMAT "", meta->size);
        }
    else
        {
            result = g_strdup("");
        }

    return result;
}


/**
 * Returns the file size from a GFile * file
 * @param file is the GFile from which we want the size.
 * @returns a guint64 that represents the file size or 0.
 */
guint64 get_file_size(GFile *file)
{
    GError *error = NULL;
    GFileInfo *fileinfo = NULL;
    guint64 size = 0;

    if (file != NULL)
        {
            fileinfo = g_file_query_info(file, "*", G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, NULL, &error);
            size = g_file_info_get_attribute_uint64(fileinfo, G_FILE_ATTRIBUTE_STANDARD_SIZE);
            free_object(fileinfo);
        }

    return size;
}


/**
 * Checks if a filename exists or not.
 * @param filename that we want to check.
 * @returns TRUE if filename exists and FALSE if not.
 */
gboolean file_exists(gchar *filename)
{
    GFile *file = NULL;
    gboolean exists = FALSE;

    if (filename != NULL)
        {
            file = g_file_new_for_path(filename);
            exists = g_file_query_exists(file, NULL);
            free_object(file);
        }

    return exists;
}


/**
 * Comparison function to be used when sorting filenames. First filenames
 * are compared and when an equality is found then the modified time is
 * compared (as a second sorting criteria)
 * @param a serveur_meta_data_t * representing a file 'a'
 * @param b serveur_meta_data_t * representing a file 'b' to be compared
 *          with 'a'
 * @returns a negative integer if the a comes before b, 0 if they are
 *          equal, or a positive integer if the a comes after b.
 */
gint compare_filenames(gconstpointer a, gconstpointer b)
{
    gchar *key_a = NULL;
    gchar *key_b = NULL;
    gint value = 0;
    serveur_meta_data_t *sa = (serveur_meta_data_t *) a;
    serveur_meta_data_t *sb = (serveur_meta_data_t *) b;


    key_a = g_utf8_collate_key_for_filename(sa->meta->name, -1);
    key_b = g_utf8_collate_key_for_filename(sb->meta->name, -1);

    value = strcmp(key_a, key_b);

    if (value == 0)
        { /* second sorting criteria : modification time */
            if (sa->meta->mtime < sb->meta->mtime)
                {
                    value = -1;
                }
            else if (sa->meta->mtime > sb->meta->mtime)
                {
                    value = 1;
                }
            else
                {
                    value = 0;
                }
        }

    free_variable(key_a);
    free_variable(key_b);

    return value;
}


/**
 * Prints a file ands its meta data to the screen
 * @param smeta is the serveur meta data of the file to be printed on the
 *        screen
 */
void print_smeta_to_screen(serveur_meta_data_t *smeta)
{
    meta_data_t *meta = NULL;   /**< helper to access smeta->meta structure do not free ! */
    GDateTime *la_date = NULL;
    gchar *the_date = NULL;

    if (smeta !=  NULL && smeta->meta != NULL)
        {
            meta = smeta->meta;

            switch (meta->file_type)
                {
                    case 1:
                        fprintf(stdout, "[FILE] ");
                    break;
                    case 2:
                        fprintf(stdout, "[DIR ] ");
                    break;
                    case 3:
                        fprintf(stdout, "[LINK] ");
                    break;
                    default:
                        fprintf(stdout, "[    ] ");
                    break;
                }

            la_date = g_date_time_new_from_unix_local(meta->mtime);
            the_date = g_date_time_format(la_date, "%F %T %z");

            fprintf(stdout, "%s ", the_date);

            fprintf(stdout, "%s\n", meta->name);

            free_variable(the_date);
            g_date_time_unref(la_date);
        }

}


/**
 * Sets file attributes
 * @param file is a GFile pointer and must not be null
 * @param meta is the structure that contains all meta datas for the
 *        file that we want to set.
 */
void set_file_attributes(GFile *file, meta_data_t *meta)
{
    GError *error = NULL;
    GFileInfo *fileinfo = NULL;

    if (file != NULL && meta != NULL)
        {
            fileinfo = g_file_query_info(file, "*", G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, NULL, &error);

            if (fileinfo == NULL || error != NULL)
                {
                    print_error(__FILE__, __LINE__, _("Error while getting file information: %s\n"), error->message);
                    error = free_error(error);
                }
            else
                {
                    set_file_mode_to_gfile(fileinfo, meta);
                    set_dates_to_gfile(fileinfo, meta);

                    if (g_file_set_attributes_from_info(file, fileinfo, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, NULL, &error) == FALSE && error != NULL)
                        {
                            print_error(__FILE__, __LINE__, _("Error or warning for file (%s): %s\n"), meta->name, error->message);
                            free_error(error);
                        }

                    free_object(fileinfo);
                }
        }
    else
        {
            /* To translators : do not translate this ! */
            print_error(__FILE__, __LINE__, "set_file_attribute(file = %p, meta = %p)\n", file, meta);
        }
}


/**
 * Makes a symbolic link named  with 'file' filename that points to the
 * target 'points_to'
 * @param file is the file to create as a symbolic link
 * @param points_to is the target of the link
 */
void make_symbolic_link(GFile *file, gchar *points_to)
{
    gchar *filename = NULL;
    GError *error = NULL;

    if (file != NULL && points_to != NULL)
        {
            if (g_file_make_symbolic_link(file, points_to, NULL, &error) == FALSE && error != NULL)
                {
                    filename = g_file_get_path(file);
                    print_error(__FILE__, __LINE__, _("Error: unable to create symbolic link %s to %s: %s.\n"), filename, points_to, error->message);
                    free_variable(filename);
                }
        }
}
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    hashs.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file hashs.c
 * This file contains the functions to deal with hashs in all the programs
 * of "Sauvegarde" project.
 */

#include "libsauvegarde.h"

/**
 * Comparison function used with the GTree structure to sort hashs
 * properly.
 * @param a is a hash in a binary form (a guint8 *)
 * @param b is a hash in a binary form to be compared with a. Comparison is
 *        done comparing byte 1 of a an b, if there equal compares byte 2
 *        and so on. Worst case is when the two hashs are equals.
 * @returns a negative value if a < b, zero if a = b and a positive value
 * if a > b.
 */
gint compare_two_hashs(gconstpointer a, gconstpointer b)
{
    guint8 *hash_a = (guint8 *) a;
    guint8 *hash_b = (guint8 *) b;
    guint first = 0;
    guint second = 0;
    guint i = 0;

    if (a != NULL)
        {
            if (b != NULL) /* a and b are not NULL -> we can compare them */
                {
                    while (first == second && i < HASH_LEN)  /* we compare bytes from the hashs (byte to byte) */
                        {
                            first = (guint) hash_a[i];
                            second = (guint) hash_b[i];
                            i = i + 1;
                        }

                    if (i == HASH_LEN && first == second) /* a is equal to b */
                        {
                            return 0;
                        }
                    if (first < second) /* a is first */
                        {
                            return -1;
                        }
                    else /* b is first */
                        {
                            return 1;
                        }
                }
            else  /* a is not NULL but b is NULL (a is first) */
                {
                    return -1;
                }
        }
    else
        {
            if (b != NULL)  /* a is NULL and b is not NULL (b is first) */
                {
                    return 1;
                }
            else  /* a and b are NULL (they are equal) */
                {
                    return 0;
                }
        }
}

/**
 * Transforms a binary hashs into a printable string (gchar *)
 * @param a_hash is a hash in a binary form that we want to transform into
 *        a string.
 * @returns a string that conatins the hash in an hexadecimal form.
 * @todo manage memory concerns here !
 */
gchar *hash_to_string(guint8 *a_hash)
{
    gchar *string = NULL;
    gchar *octet = NULL;
    guint i = 0;

    if (a_hash != NULL)
        {
            string = (gchar *) g_malloc0(HASH_LEN*2 + 1); /* two char per bytes */
            octet = (gchar *) g_malloc0(3);

            for(i = 0; i < HASH_LEN; i++)
                {
                    octet = g_strdup_printf("%02x", a_hash[i]);
                    memmove(string + i*2, octet, 2);
                }
        }

    free_variable(octet);
    return string;
}


/**
 * @param value is the gchar to be evaluated (should be 0 to 9 or a to f)
 * @returns the guint value of a gchar character.
 * @note this "stupid" function as a CCN of 17 ! Avoid complexification
 *       of this function if you want to go for a CCN below 10.
 */
static guint int_value(gchar value)
{
    switch (value)
        {
            case '0' :
                return 0;
                break;
            case '1' :
                return 1;
                break;
            case '2' :
                return 2;
                break;
            case '3' :
                return 3;
                break;
            case '4' :
                return 4;
                break;
            case '5' :
                return 5;
                break;
            case '6' :
                return 6;
                break;
            case '7' :
                return 7;
                break;
            case '8' :
                return 8;
                break;
            case '9' :
                return 9;
                break;
            case 'a' :
                return 10;
                break;
            case 'b' :
                return 11;
                break;
            case 'c' :
                return 12;
                break;
            case 'd' :
                return 13;
                break;
            case 'e' :
                return 14;
                break;
            case 'f' :
                return 15;
                break;
            default :
                return 0;  /* This default case should never happen */
                break;
        }
}


/**
 * Transforms a binary hashs into a printable string (gchar *)
 * @param str_hash a string (gchar *) that conatins the hash in an
 *        hexadecimal form.
 * @returns a hash in a binary form (guint8 *).
 */
guint8 *string_to_hash(gchar *str_hash)
{
    guint8 *string = NULL;
    guint8 octet = 0;
    guint i = 0;

    if (str_hash != NULL)
        {
            string = (guint8 *) g_malloc0(HASH_LEN + 1); /* two char per bytes */

            for(i = 0; i < HASH_LEN * 2; i = i + 2)
                {
                    octet = int_value(str_hash[i])*16 + int_value(str_hash[i+1]);
                    memmove(string + i/2, &octet, 1);
                }
        }

    return string;
}


/**
 * Creates a new data_t * structure populated with the buffer and its size.
 * @param buffer : the data to be stored
 * @param read : the size of that buffer
 * @param into_cache : says wether it is already into the cache (TRUE) or
 *        not (FALSE)
 * @returns a newly allocated data_t * structure that can be freed when no
 *         longer needed.
 */
data_t *new_data_t_structure(guchar *buffer, gssize read, gboolean into_cache)
{
    data_t *a_data;

    a_data = (data_t *) g_malloc0(sizeof(data_t));

    a_data->buffer = buffer;
    a_data->read = read;
    a_data->into_cache = into_cache;

    return a_data;
}


/**
 * Frees data buffer and returns NULL.
 * @param a_data : the stucture that contains buffer data and its size to
 * be freed
 * @returns always NULL.
 */
gpointer free_data_t_structure(data_t *a_data)
{

    if (a_data != NULL)
        {
            a_data->buffer = free_variable(a_data->buffer);
            free_variable(a_data);
        }

    return NULL;
}


/**
 * Frees hash_data_t *buffer and returns NULL.
 * @param hash_data : the stucture that contains buffer data, hash data
 *        and its size to be freed.
 * @returns always NULL.
 */
gpointer free_hash_data_t_structure(hash_data_t *hash_data)
{

    if (hash_data != NULL)
        {
            free_variable(hash_data->data);
            free_variable(hash_data->hash);
            free_variable(hash_data);
        }

    return NULL;
}


/**
 * handler for g_slist_free_full
 * @param data must be a hash_data_t * structure.
 */
void free_hdt_struct(gpointer data)
{
    free_hash_data_t_structure(data);
}


/**
 * Inits and returns a newly hash_data_t structure.
 * @returns a newly hash_data_t structure.
 */
hash_data_t *new_hash_data_t(guchar *data, gssize read, guint8 *hash)
{
    hash_data_t *hash_data = NULL;

    hash_data = (hash_data_t *) g_malloc0(sizeof(hash_data_t));

    hash_data->hash = hash;
    hash_data->data = data;
    hash_data->read = read;

    return hash_data;
}


/**
 * Converts the hash list to a list of comma separated hashs in one gchar *
 * string. Hashs are base64 encoded
 * @param hash_list  GSList of hash_data_t * elements
 * @returns a list of comma separated hashs in one gchar * string.
 */
gchar *convert_hash_data_list_to_gchar(GSList *hash_list)
{
    GSList *head = hash_list;
    gchar *base64 = NULL;
    gchar *list = NULL;
    gchar *old_list = NULL;
    hash_data_t *hash_data = NULL;

    while (head != NULL)
        {
            hash_data = head->data;
            base64 = g_base64_encode(hash_data->hash, HASH_LEN);

            if (old_list == NULL)
                {
                    list = g_strdup_printf("\"%s\"", base64);
                    old_list = list;
                }
            else
                {
                    list = g_strdup_printf("%s, \"%s\"", old_list, base64);
                    free_variable(old_list);
                    old_list = list;
                }

            free_variable(base64);

            head = g_slist_next(head);
        }

    list = old_list;

    return list;
}


/**
 * Makes a path from a binary hash : 0E/39/AF for level 3 with hash (in hex)
 * begining by 0E39AF.
 * @param path is a gchar * prefix for the path (ie /var/tmp/sauvegarde for
 *        instance).
 * @param hash is a guint8 pointer to the binary representation of a hash.
 * @param level The level we want the path to have. It is an unsigned int
 *        and must be less than HASH_LEN. a level of N gives 2^N
 *        directories. We should add a level when more than 512 files are
 *        in each last subdirectories.
 * @returns a string as a gchar * made of the path and the hex
 *          representation of hash on 'level' levels. With the example above
 *          it will return /var/tmp/sauvegarde/0E/39/AF
 */
gchar *make_path_from_hash(gchar *path, guint8 *hash, guint level)
{
    gchar *octet = NULL;
    gchar *old_path = NULL;
    gchar *new_path = NULL;
    guint i = 0;

    if (path != NULL && hash != NULL && level < HASH_LEN)
        {

            old_path = g_strdup(path);

            for(i = 0; i < level; i++)
                {
                    octet = g_strdup_printf("%02x", hash[i]);
                    new_path = g_build_filename(old_path, octet, NULL);

                    free_variable(old_path);
                    free_variable(octet);

                    old_path = new_path;
                }
        }

    return old_path;
}


/**
 * makes a GSList of hash_data_t * element where 'hash' field is base64
 * decoded hashs from a string containning base64 * encoded hashs that
 * must be separated by comas.
 * @param the string containing base64 encoded hashs such as : *
 *        "cCoCVkt/AABf04jn2+rfDmqJaln6P2A9uKolBjEFJV4=", "0G8MaPZ/AADNyaPW7ZP2s0BI4hAdZZIE2xO1EwdOzhE="
 *        for instance.
 * @returns a GSList of hash_data_t * where each elements contains a
 *          base64 decoded hash (binary form).
 */
GSList *make_hash_data_list_from_string(gchar *hash_string)
{
    uint i = 0;
    gchar **hashs = NULL;
    gchar *a_hash = NULL;
    hash_data_t *hash_data = NULL;
    GSList *hash_list = NULL;
    gsize len = 0;

    if (hash_string != NULL)
        {
            /* hash list generation */
            hashs = g_strsplit(hash_string, ",", -1);

            while (hashs[i] != NULL)
                {
                    a_hash = g_strndup(g_strchug(hashs[i] + 1), strlen(g_strchug(hashs[i])) - 2);

                    /* we have to base64 decode it to insert it into the hash_data_t * structure
                     * and then into the meta_data one.
                     */
                    hash_data = new_hash_data_t(NULL, 0, g_base64_decode(a_hash, &len));
                    hash_list = g_slist_prepend(hash_list, hash_data);
                    free_variable(a_hash);
                    i = i + 1;
                }

            g_strfreev(hashs);

            hash_list = g_slist_reverse(hash_list);
        }

    return hash_list;
}
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    communique.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file communique.h
 * This file contains all definitions and functions calls to the zmq
 * library
 */

#ifndef _COMMUNIQUE_H_
#define _COMMUNIQUE_H_


/**
 * @def MAX_MESSAGE_SIZE
 * Defines the maximum message size that we will be able to send or receive
 * default is 131072
 */
#define MAX_MESSAGE_SIZE (131072)


/**
 * @struct comm_t
 * @brief Structure that will contain everything needed to the
 *        communication layer.
 */
typedef struct
{
    CURL *curl_handle; /**< Curl easy handle for a connection                */
    gchar *buffer;     /**< Buffer to pass things from the callback function */
    gchar *conn;       /**< Connexion string that should be http://ip:port   */
    gint seq;          /**< sequence number when receiving multiples parts   */
} comm_t;


/**
 * gets the version for the communication library (ZMQ for now)
 * @returns a newly allocated string that contains the version and that
 *          may be freed with free_variable() when no longer needed.
 */
extern gchar *get_communication_library_version(void);


/**
 * Makes the connexion string that is used by ZMQ to create a new socket
 * and verifies that port number is between 1025 and 65534 included.
 * @param ip : a gchar * that contains either an ip address or a hostname
 * @param port : a gint that is comprised between 1025 and 65534 included
 * @returns a newly allocated string that may be freed with free_variable()
 *          function.
 */
extern gchar *make_connexion_string(gchar *ip, gint port);


/**
 * Creates a new communication comm_t * structure.
 * @param conn a gchar * connection string that should be some url like
 *        string : http://ip:port or http://servername:port
 * @returns a newly allocated comm_t * structure where sender and receiver
 *          are set to NULL.
 */
extern comm_t *init_comm_struct(gchar *conn);


/**
 * Uses curl to send a GET command to the http url
 * @param comm a comm_t * structure that must contain an initialized
 *        curl_handle (must not be NULL)
 * @param url a gchar * url where to send the command to (must not be NULL)
 * @returns a CURLcode (http://curl.haxx.se/libcurl/c/libcurl-errors.html)
 *          CURLE_OK upon success, any other error code in any other
 *          situation. When CURLE_OK is returned, the datas that the server
 *          sent is in the comm->buffer gchar * string.
 */
extern gint get_url(comm_t *comm, gchar *url);


/**
 * Uses curl to send a POST command to the http server url
 * @param comm a comm_t * structure that must contain an initialized
 *        curl_handle (must not be NULL). buffer field of this structure
 *        is send as data in the POST command.
 * @param url a gchar * url where to send the command to. It must NOT
 *        contain the http://ip:port string. And must contain the first '/'
 *        ie to get 'http://127.0.0.1:5468/Version' url must be '/Version'.
 * @returns a CURLcode (http://curl.haxx.se/libcurl/c/libcurl-errors.html)
 *          CURLE_OK upon success, any other error code in any other
 *          situation. When CURLE_OK is returned, the datas that the server
 *          sent is in the comm->buffer gchar * string.
 */
extern gint post_url(comm_t *comm, gchar *url);


/**
 * Checks wether the serveur is alive or not and checks its version
 * @param comm a comm_t * structure that must contain an initialized
 *        curl_handle (must not be NULL).
 * @returns TRUE if the serveur is alive and has a correct version.
 *          FALSE otherwise
 */
extern gboolean is_serveur_alive(comm_t *comm);


/**
 * Frees and releases a comm_t *structure
 * @param comm a comm_t * structure to be freed
 */
extern void free_comm_t(comm_t *comm);

#endif /* #ifndef _COMMUNIQUE_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    configuration.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file configuration.h
 *
 * This file contains all the definitions for the tools that deals with
 * the configuration file of "Sauvegarde" programs.
 */
#ifndef _CONFIGURATION_H_
#define _CONFIGURATION_H_

/**
 * @note on key naming scheme :
 *
 *  GN == Group Name that will group KN_* keys used for a same purpose or
 *        a same program. It should begin with an uppercase letter.
 *  KN == Key Name that will stor a value or a list of values. It should
 *        be lowercase only.
 *
 * To translators : thoses key names and group names must not be translated.
 */

 /**
  * @def GN_MONITOR
  * Defines the group name for all preferences related to "monitor"
  * program.
  *
  * @def GN_CISEAUX
  * Defines the group name for all preferences related to "ciseaux"
  * program.
  *
  * @def GN_ANTEMEMOIRE
  * Defines the group name for all preferences related to "antememoire"
  * program.
  *
  * @def GN_SERVEUR
  * Defines the group name for all preferences related to "serveur"
  * program.
  *
  * @def GN_ALL
  * Defines the group name for all preferences related to all programs
  *
  */
#define GN_MONITOR ("Monitor")
#define GN_CISEAUX ("Ciseaux")
#define GN_ANTEMEMOIRE ("AnteMemoire")
#define GN_SERVEUR ("Serveur")
#define GN_ALL ("All")


/** Below you'll find some definitions for all the programs */
/**
 * @def KN_DEBUG_MODE
 * Defines the key name for debug mode that may be used by any program
 * in configuration files.
 */
#define KN_DEBUG_MODE ("debug-mode")


/** Below you'll find some definitions for the ciseaux program */
/**
 * @def KN_BLOCK_SIZE
 * Defines the key name for the blocksize option. Expected value is of
 * type gint64 but may only be positive.
 */
#define KN_BLOCK_SIZE ("blocksize")


/** Below you'll find some definitions for the monitor program */
/**
 * @def KN_DIR_LIST
 * Defines a list of directories that we want to watch.
 */
#define KN_DIR_LIST ("directory-list")


/** Below you'll find some definitions for the antememoire program */
/**
 * @def KN_CACHE_DIR
 * Defines a directory where we will put some cache files and stuff
 * temporary needed to do the job. The program needs write access to this
 * directory.
 */
#define KN_CACHE_DIR ("cache-directory")


/**
 * @def KN_DB_NAME
 * Defines the name of the database to be used for the local cache
 */
#define KN_DB_NAME ("cache-db-name")


/**
 * @def KN_SERVEUR_IP
 * Defines server's IP address for the client.
 */
#define KN_SERVEUR_IP ("serveur-ip")


/** Below you'll find some definitions for the serveur program */
/**
 * @def KN_SERVEUR_PORT
 * Defines the port number on which serveur program will listen for
 * connexions
 */
#define KN_SERVEUR_PORT ("serveur-port")


/**
 * Gets the probable filename for the configuration file of sauvegarde
 * project. This is needed when one wants to install the project in an
 * uncommon location such as a homedir for instance.
 * @param progname is the name of the program we want to search for in the
 *        user's path
 * @param default configuration file name that should be a const string.
 * @returns a gchar * which contain the filename of the configuration file
 *          relative to progname or NULL if something went wrong.
 */
extern gchar *get_probable_etc_path(gchar *progname, const gchar *configfile);


/**
 * This functions converts a gchar ** array to a GSList of gchar *.
 * The function appends to the list first_list (if it exists - it may be
 * NULL) each entry of the array so elements are in the same order in the
 * array and in the list.
 * @param array is a gchar * array.
 * @param first_list is a list that may already contain some elements and
 *        to which we will add all the elements of 'array' array.
 * @returns a newly allocated GSList that may be freed when no longer
 *          needed or NULL if array is NULL.
 */
extern GSList *convert_gchar_array_to_GSList(gchar **array, GSList *first_list);


/**
 * Reads a string from keyname key in the group grouname from keyfile file
 * and displays errormsg in case of an error
 * @param keyfile : the opened keyfile to read from
 * @param filename : the filename of the keyfile file
 * @param groupname : the groupname where to look for the key
 * @param keyname : the key to read the string from
 * @param errormsg : the error message to be displayed in case of an error
 * @returns the string read at the keyname in the groupname of keyfile
 *          file.
 */
extern gchar *read_string_from_file(GKeyFile *keyfile, gchar *filename, gchar *groupname, gchar *keyname, gchar *errormsg);


/**
 * Reads a gint64 from keyname key in the group grouname from keyfile file
 * and displays errormsg in case of an error
 * @param keyfile : the opened keyfile to read from
 * @param filename : the filename of the keyfile file
 * @param groupname : the groupname where to look for the key
 * @param keyname : the key to read the gint64 from
 * @param errormsg : the error message to be displayed in case of an error
 * @returns the gint64 read at the keyname in the groupname of keyfile
 *          file or 0;
 */
extern gint64 read_int64_from_file(GKeyFile *keyfile, gchar *filename, gchar *groupname, gchar *keyname, gchar *errormsg);


/**
 * Reads an integer from keyname key in the group grouname from keyfile file
 * and displays errormsg in case of an error
 * @param keyfile : the opened keyfile to read from
 * @param filename : the filename of the keyfile file
 * @param groupname : the groupname where to look for the key
 * @param keyname : the key to read the gint from
 * @param errormsg : the error message to be displayed in case of an error
 * @returns the gint read at the keyname in the groupname of keyfile
 *          file or 0;
 */
extern gint read_int_from_file(GKeyFile *keyfile, gchar *filename, gchar *groupname, gchar *keyname, gchar *errormsg);


/**
 * Reads an integer from keyname key in the group grouname from keyfile file
 * and displays errormsg in case of an error
 * @param keyfile : the opened keyfile to read from
 * @param filename : the filename of the keyfile file
 * @param groupname : the groupname where to look for the key
 * @param keyname : the key to read the gboolean from
 * @param errormsg : the error message to be displayed in case of an error
 * @returns the boolean read at the keyname in the groupname of keyfile
 *          file or FALSE;
 */
extern gboolean read_boolean_from_file(GKeyFile *keyfile, gchar *filename, gchar *groupname, gchar *keyname, gchar *errormsg);


/**
 * Reads a list of gchar * from keyname key in the group grouname from
 * keyfile file and displays errormsg in case of an error
 * @param keyfile : the opened keyfile to read from
 * @param filename : the filename of the keyfile file
 * @param groupname : the groupname where to look for the key
 * @param keyname : the key to read the list of gchar * from
 * @param errormsg : the error message to be displayed in case of an error
 * @returns the list of gchar * read at the keyname in the groupname of
 *          keyfile file or NULL;
 */
extern GSList *read_list_from_file(GKeyFile *keyfile, gchar *filename, gchar *groupname, gchar *keyname, gchar *errormsg);


#endif /* #ifndef _CONFIGURATION_H_ */
/* gprof-helper.c -- preload library to profile pthread-enabled programs
 *
 * Authors: Sam Hocevar <sam at zoy dot org>
 *          Daniel Jnsson <danieljo at fagotten dot org>
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the Do What The Fuck You Want To
 *  Public License as published by Banlu Kemiyatorn. See
 *  http://sam.zoy.org/projects/COPYING.WTFPL for more details.
 *
 * Compilation example:
 * gcc -shared -fPIC gprof-helper.c -o gprof-helper.so -lpthread -ldl
 *
 * Usage example:
 * LD_PRELOAD=./gprof-helper.so your_program
 */

#define _GNU_SOURCE
#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>
#include <pthread.h>

static void * wrapper_routine(void *);

/* Original pthread function */
static int (*pthread_create_orig)(pthread_t *__restrict,
                                  __const pthread_attr_t *__restrict,
                                  void *(*)(void *),
                                  void *__restrict) = NULL;

/* Library initialization function */
void wooinit(void) __attribute__((constructor));

void wooinit(void)
{
    pthread_create_orig = dlsym(RTLD_NEXT, "pthread_create");
    fprintf(stderr, "pthreads: using profiling hooks for gprof\n");
    if(pthread_create_orig == NULL)
    {
        char *error = dlerror();
        if(error == NULL)
        {
            error = "pthread_create is NULL";
        }
        fprintf(stderr, "%s\n", error);
        exit(EXIT_FAILURE);
    }
}

/* Our data structure passed to the wrapper */
typedef struct wrapper_s
{
    void * (*start_routine)(void *);
    void * arg;

    pthread_mutex_t lock;
    pthread_cond_t  wait;

    struct itimerval itimer;

} wrapper_t;

/* The wrapper function in charge for setting the itimer value */
static void * wrapper_routine(void * data)
{
    /* Put user data in thread-local variables */
    void * (*start_routine)(void *) = ((wrapper_t*)data)->start_routine;
    void * arg = ((wrapper_t*)data)->arg;

    /* Set the profile timer value */
    setitimer(ITIMER_PROF, &((wrapper_t*)data)->itimer, NULL);

    /* Tell the calling thread that we don't need its data anymore */
    pthread_mutex_lock(&((wrapper_t*)data)->lock);
    pthread_cond_signal(&((wrapper_t*)data)->wait);
    pthread_mutex_unlock(&((wrapper_t*)data)->lock);

    /* Call the real function */
    return start_routine(arg);
}

/* Our wrapper function for the real pthread_create() */
int pthread_create(pthread_t *__restrict thread,
                   __const pthread_attr_t *__restrict attr,
                   void * (*start_routine)(void *),
                   void *__restrict arg)
{
    wrapper_t wrapper_data;
    int i_return;

    /* Initialize the wrapper structure */
    wrapper_data.start_routine = start_routine;
    wrapper_data.arg = arg;
    getitimer(ITIMER_PROF, &wrapper_data.itimer);
    pthread_cond_init(&wrapper_data.wait, NULL);
    pthread_mutex_init(&wrapper_data.lock, NULL);
    pthread_mutex_lock(&wrapper_data.lock);

    /* The real pthread_create call */
    i_return = pthread_create_orig(thread,
                                   attr,
                                   &wrapper_routine,
                                   &wrapper_data);

    /* If the thread was successfully spawned, wait for the data
     * to be released */
    if(i_return == 0)
    {
        pthread_cond_wait(&wrapper_data.wait, &wrapper_data.lock);
    }

    pthread_mutex_unlock(&wrapper_data.lock);
    pthread_mutex_destroy(&wrapper_data.lock);
    pthread_cond_destroy(&wrapper_data.wait);

    return i_return;
}

/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    options.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file serveur/options.h
 *
 * This file contains all the definitions for the options of the command
 * line for 'serveur' program. It is very similar to monitor's options.h
 * file.
 *
 */
#ifndef _SERVEUR_OPTIONS_H_
#define _SERVEUR_OPTIONS_H_

/**
 * @struct options_t
 * @brief Selected options for 'serveur' program
 *
 * Structure Options gives a way to store program options passed from the
 * command line or read from a configuration file for 'serveur' program.
 */
typedef struct
{
    gboolean version;   /**< TRUE if we have to display program's version                        */
    gchar *configfile;  /**< filename for the configuration file specified on the command line   */
    gint port;         /**< port number on which the serveur program will listen for connexions */
} options_t;



/**
 * Frees the options structure if necessary
 * @param opt : the malloc'ed options_t structure
 */
extern void free_options_t_structure(options_t *opt);

/**
 * creates a buffer containing every selected options ...
 * @param opt the options_t * structure that contains all selected options
 *        from the command line and that will be used by the program.
 * @returns options as selected when invoking the program with -v option
 * into a newly allocated buffer that may be freed when no longer needed
 */
extern gchar *buffer_selected_option(options_t *opt);


/**
 * This function parses command line options. It sets the options in this
 * order. It means that the value used for an option is the one set in the
 * lastest step.
 * 0) default values are set into the options_t * structure
 * 1) reads the default configuration file if any.
 * 2) reads the configuration file mentionned on the command line.
 * 3) sets the command line options (except for the list of directories,
 *    all other values are replaced by thoses in the command line)
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 * @returns options_t structure malloc'ed and filled upon choosen command
 *          line's option
 */
extern options_t *manage_command_line_options(int argc, char **argv);


/**
 * Decides what to do upon command lines options passed to the program
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 * @returns options_t structure malloc'ed and filled upon choosen command
 *          line's option (in manage_command_line_options function).
 */
extern options_t *do_what_is_needed_from_command_line_options(int argc, char **argv);


#endif /* #IFNDEF _SERVEUR_OPTIONS_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    backend.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file serveur/backend.h
 *
 * This file contains all the definitions for the backend management of
 * serveur's server.
 */
#ifndef _SERVEUR_BACKEND_H_
#define _SERVEUR_BACKEND_H_

/**
 * Function templates definition to be used by backend_t structure.
 * void * pointers are ment to be serveur_struct_t * pointers.
 * @todo have a function that will say if a hash and its associated data
 *       have already been stored.
 * @todo have a function that will be called when reading configuration
 *       file to access some specific backend configurations.
 * @todo try to imagine a solution to append backend specific new options
 *       to the command line.
 */
typedef void (* store_smeta_func) (void *, serveur_meta_data_t *);   /**< Stores a serveur_meta_data_t structure according to the backend                            */
typedef void (* store_data_func) (void *, hash_data_t *);            /**< Stores a hash_data_t structure according to the backend                                    */
typedef GSList * (* build_needed_hash_list_func) (void *, GSList *); /**< A function that will check if a hash is already known and build a list
                                                                      *   of needed hashs that the client may send                                                   */
typedef void (* init_backend_func) (void *);                         /**< A function that will initialize the backend if needed                                      */
typedef gchar * (* get_list_of_files_func) (void *, query_t *);      /**< A function that returns a JSON formatted string of saved files corresponding to the query  */
typedef hash_data_t * (* retrieve_data_func) (void *, gchar *);      /**< A function that returns the buffer associated to a specific hash                           */


/**
 * @struct backend_t
 * @brief This structure contains pointers to the selected backend functions.
 */
typedef struct
{
    store_smeta_func store_smeta;
    store_data_func store_data;
    build_needed_hash_list_func build_needed_hash_list;
    init_backend_func init_backend;
    get_list_of_files_func get_list_of_files;
    retrieve_data_func retrieve_data;
    void *user_data;                                     /**< user_data should be used by backends to store their own internal structure */
} backend_t;



/**
 * Inits the backend with the correct functions
 * @param store_smeta a function to store serveur meta data structure
 * @param store_data a function to store datas
 * @param init_backend a function to init the backend
 * @param build_needed_hash_list a function that must build a GSList * needed hash list
 * @param get_list_of_files gets the list of saved files
 * @param retrieve_data retrieves data from a specified hash.
 * @returns a newly created backend_t structure initialized to nothing !
 */
extern backend_t *init_backend_structure(void *store_smeta, void *store_data, void *init_backend, void *build_needed_hash_list, void *get_list_of_files, void * retrieve_data);





#endif /* #ifndef _SERVEUR_BACKEND_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    file_backend.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file serveur/file_backend.c
 *
 * This file contains all the functions for the file backend that saves
 * everything to some flat files somewhere into the filesystem.
 *
 * @note to translators: file_backend is the name of the backend please
 * do not translate this. Thanks.
 */

#include "serveur.h"


static void file_create_directory(gchar *save_dir, gchar *sub_dir);
static void make_all_subdirectories(file_backend_t *file_backend);
static buffer_t *init_buffer_structure(GFileInputStream *stream);
static void free_buffer_t(buffer_t *a_buffer);
static void read_one_buffer(buffer_t *a_buffer);
static gchar *extract_one_line_from_buffer(buffer_t *a_buffer);
static guint64 get_guint64_from_string(gchar *string);
static uint get_uint_from_string(gchar *string);
static gboolean compare_mtime_to_date(guint64 mtime, gchar *date);
static meta_data_t *extract_from_line(gchar *line, GRegex *a_regex, query_t *query);


/**
 * Stores meta data into a flat file. A file is created for each host that
 * sends meta datas. This code is not thread safe (it means that this is
 * not safe to call it from different threads unless some mechanism
 * garantees that a write will never occur in the same file at the same
 * time.
 * @param serveur_struct is the serveur main structure where all
 *        informations needed by the program are stored.
 * @param smeta the serveur structure for file meta data. It contains the
 *        hostname that sent it. This structure IS FREED by this
 *        function.
 * @todo prefix should be set as a configuration's option.
 */
void file_store_smeta(serveur_struct_t *serveur_struct, serveur_meta_data_t *smeta)
{
    GFile *meta_file = NULL;
    gchar *filename = NULL;
    GFileOutputStream *stream = NULL;
    GError *error = NULL;
    gsize count = 0;
    gssize written = 0;
    gchar *buffer = NULL;
    gchar *hash_list = NULL;
    meta_data_t *meta = NULL;
    gchar *prefix = NULL;
    file_backend_t *file_backend = NULL;


    if (serveur_struct != NULL && serveur_struct->backend != NULL && serveur_struct->backend->user_data != NULL && smeta != NULL)
        {
            meta = smeta->meta;
            file_backend = serveur_struct->backend->user_data;
            prefix = g_build_filename((gchar *) file_backend->prefix, "metas", NULL);

            if (smeta->hostname != NULL && meta != NULL)
                {
                    filename = g_build_filename(prefix, smeta->hostname, NULL);

                    meta_file = g_file_new_for_path(filename);

                    stream = g_file_append_to(meta_file, G_FILE_CREATE_NONE, NULL, &error);

                    if (stream != NULL)
                        {
                            hash_list = convert_hash_data_list_to_gchar(meta->hash_data_list);

                            if (hash_list != NULL)
                                {
                                    buffer = g_strdup_printf("%d, %" G_GUINT64_FORMAT ", %d, %" G_GUINT64_FORMAT ", %" G_GUINT64_FORMAT ", %" G_GUINT64_FORMAT ", %" G_GUINT64_FORMAT ", \"%s\", \"%s\", %d, %d, \"%s\", \"%s\", %s\n", meta->file_type, meta->inode, meta->mode, meta->atime, meta->ctime, meta->mtime, meta->size, meta->owner, meta->group, meta->uid, meta->gid, meta->name, meta->link, hash_list);
                                    free_variable(hash_list);
                                }
                            else
                                {
                                    buffer = g_strdup_printf("%d, %" G_GUINT64_FORMAT ", %d, %" G_GUINT64_FORMAT ", %" G_GUINT64_FORMAT ", %" G_GUINT64_FORMAT ", %" G_GUINT64_FORMAT ", \"%s\", \"%s\", %d, %d, \"%s\", \"%s\"\n", meta->file_type, meta->inode, meta->mode, meta->atime, meta->ctime, meta->mtime, meta->size, meta->owner, meta->group, meta->uid, meta->gid, meta->name, meta->link);
                                }

                            count = strlen(buffer);
                            written = g_output_stream_write((GOutputStream *) stream, buffer, count, NULL, &error);

                            if (error != NULL)
                                {
                                    print_error(__FILE__, __LINE__, _("Error: unable to write to file %s (%ld bytes written).\n"), filename, written);
                                }

                            g_output_stream_close((GOutputStream *) stream, NULL, &error);
                            free_variable(buffer);
                        }
                    else
                        {
                            print_error(__FILE__, __LINE__, _("Error: unable to open file %s to append meta-datas in it.\n"), filename);
                        }

                    free_object(meta_file);
                    free_variable(filename);
                }
            else
                {
                    print_error(__FILE__, __LINE__, _("Error: no serveur_meta_data_t structure or missing hostname or missing meta_data_t * structure.\n"));
                }

            free_variable(prefix);
        }
}


/**
 * Stores data into a flat file. The file is named by its hash in hex
 * representation (one should easily check that the sha256sum of such a
 * file gives its name !).
 * @param serveur_struct is the serveur main structure where all
 *        informations needed by the program are stored.
 * @param hash_data is a hash_data_t * structure that contains the hash and
 *        the corresponding data in a binary form and a 'read' field that
 *        contains the number of bytes in 'data' field.
 * @todo prefix should be set as a configuration's option.
 */
void file_store_data(serveur_struct_t *serveur_struct, hash_data_t *hash_data)
{
    GFile *data_file = NULL;
    gchar *filename = NULL;
    GFileOutputStream *stream = NULL;
    GError *error = NULL;
    gssize written = 0;
    gchar *hex_hash = NULL;
    gchar *path = NULL;
    gchar *prefix = NULL;
    file_backend_t *file_backend = NULL;

    if (serveur_struct != NULL && serveur_struct->backend != NULL && serveur_struct->backend->user_data != NULL)
        {
            file_backend = serveur_struct->backend->user_data;
            prefix = g_build_filename((gchar *) file_backend->prefix, "datas", NULL);

            if (hash_data != NULL && hash_data->hash != NULL && hash_data->data != NULL)
                {
                    path = make_path_from_hash(prefix, hash_data->hash, file_backend->level);
                    hex_hash = hash_to_string(hash_data->hash);
                    filename = g_build_filename(path, hex_hash, NULL);

                    data_file = g_file_new_for_path(filename);
                    stream = g_file_replace(data_file, NULL, FALSE, G_FILE_CREATE_NONE, NULL, &error);

                    if (stream != NULL)
                        {
                            written = g_output_stream_write((GOutputStream *) stream, hash_data->data, hash_data->read, NULL, &error);

                            if (error != NULL)
                                {
                                    print_error(__FILE__, __LINE__, _("Error: unable to write to file %s (%ld bytes written).\n"), filename, written);
                                }

                            g_output_stream_close((GOutputStream *) stream, NULL, &error);

                            free_variable(hash_data->data);
                            free_variable(hash_data->hash);
                            free_variable(hash_data);
                        }
                    else
                        {
                            print_error(__FILE__, __LINE__, _("Error: unable to open file %s to write datas in it.\n"), filename);
                        }

                    free_object(data_file);
                    free_variable(filename);
                    free_variable(hex_hash);
                    free_variable(path);
                }
            else
                {
                    print_error(__FILE__, __LINE__, _("Error: no hash_data_t structure or hash in it or missing data in it.\n"));
                }

            free_variable(prefix);
        }
}


/**
 * Builds a list of hashs that serveur's server need.
 * @param serveur_struct is the serveur main structure where all
 *        informations needed by the program are stored.
 * @param hash_list is the list of hashs that we have to check for.
 * @returns to the client a list of hashs in no specific order for which
 *          the server needs the datas.
 */
GSList *file_build_needed_hash_list(serveur_struct_t *serveur_struct, GSList *hash_data_list)
{
    GFile *data_file = NULL;
    GSList *head = hash_data_list;
    GSList *needed = NULL;
    gchar *hex_hash = NULL;
    gchar *filename = NULL;
    gchar *path = NULL;
    gchar *prefix = NULL;
    file_backend_t *file_backend = NULL;
    guint8 *a_hash = NULL;
    hash_data_t *hash_data = NULL;
    hash_data_t *needed_hash_data = NULL;


    if (serveur_struct != NULL && serveur_struct->backend != NULL && serveur_struct->backend->user_data != NULL)
        {
            file_backend = serveur_struct->backend->user_data;

            prefix = g_build_filename((gchar *) file_backend->prefix, "datas", NULL);

            while (head != NULL)
                {
                    hash_data = head->data;
                    path = make_path_from_hash(prefix, hash_data->hash, file_backend->level);
                    hex_hash = hash_to_string(hash_data->hash);

                    filename = g_build_filename(path, hex_hash, NULL);
                    data_file = g_file_new_for_path(filename);

                    if (g_file_query_exists(data_file, NULL) == FALSE)
                        {
                            /* file does not exists and is needed thus putting it it the needed list */
                            a_hash = (guint8 *) g_malloc0(sizeof(guint8) * HASH_LEN);
                            memcpy(a_hash, hash_data->hash, HASH_LEN);
                            needed_hash_data = new_hash_data_t(NULL, 0, a_hash);
                            needed = g_slist_prepend(needed, needed_hash_data);
                        }

                    free_object(data_file);
                    free_variable(filename);
                    free_variable(hex_hash);
                    free_variable(path);

                    head = g_slist_next(head);
                }

            free_variable(prefix);
        }

    return needed;
}


/**
 * Creates sub_dir subdirectory into save_dir path
 * @param save_dir prefix directory where to create sub_dir
 * @param sub_dir name of the sub directory to be created under save_dir
 */
static void file_create_directory(gchar *save_dir, gchar *sub_dir)
{
    gchar *a_directory = NULL;

    a_directory = g_build_filename(save_dir, sub_dir, NULL);
    create_directory(a_directory);
    free_variable(a_directory);
}


/**
 * Makes all subdirectories into the "datas" directory.
 * @note creating subdirectories for a level of 2 will take some time and
 *       the empty directories will consume at least 256 Mb of space (ext4
 *       filesystem). A level of 3 will take a long time and will consume
 *       at least like 64 Gb of space (ext4 filesystem). Expect 16 Tb with
 *       level 4 and a very very long time to complete.
 * @param file_backend the structure that contains the prefix path and the
 *        level in which we want to create the subdirectories.
 */
static void make_all_subdirectories(file_backend_t *file_backend)
{
    gchar *path = NULL;
    gchar *path2 = NULL;
    gchar *octet = NULL;
    guint number = 0;
    double i = 0;
    double p = 0;
    double total = 0;

    if (file_backend != NULL && file_backend->level < 5 && file_backend->level > 1)
        {
            total = pow(256, file_backend->level);

            for (i = 0; i < total; i++)
                {
                    path = g_strdup("");

                    for (p = file_backend->level-1; p >= 0; p--)
                        {
                            number = i / (pow(256, p));


                            if (number > 255)
                                {
                                    number = fmod(number, 256);
                                }


                            octet = g_strdup_printf("%02x", number);
                            path2 = g_strconcat(path, octet, "/", NULL);
                            free_variable(path);
                            path = path2;
                            free_variable(octet);
                        }

                    path[strlen(path)-1] = '\0';
                    path2 = g_build_filename(file_backend->prefix, "datas", path, NULL);

                    create_directory(path2);

                    free_variable(path);
                    free_variable(path2);

                }

            /* Creates a directory named .done in prefix/datas in order
             * to tell that we already have created all direcrories an subdirectories
             */
            path =  g_build_filename(file_backend->prefix, "datas", ".done", NULL);
            create_directory(path);
            free_variable(path);
        }
}


/**
 * Inits the backend : takes care of the directories we want to write to.
 * user_data of the backend structure is a file_backend_t structure that
 * contains the prefix path where to store datas and the level of
 * indirections
 * @param serveur_struct is the serveur main structure where all
 *        informations needed by the program are stored.
 */
void file_init_backend(serveur_struct_t *serveur_struct)
{
    file_backend_t *file_backend = NULL;
    gchar *path = NULL;

    if (serveur_struct != NULL && serveur_struct->backend != NULL)
        {
            file_backend = (file_backend_t *) g_malloc0(sizeof(file_backend_t));

            file_backend->prefix = g_strdup("/var/tmp/sauvegarde/serveur");
            file_backend->level = 2;  /* default level */

            serveur_struct->backend->user_data = file_backend;

            file_create_directory(file_backend->prefix, "metas");
            file_create_directory(file_backend->prefix, "datas");

            path =  g_build_filename(file_backend->prefix, "datas", ".done", NULL);
            if (file_exists(path) == FALSE)
                {
                    fprintf(stdout, _("Please wait while creating directories\n"));
                    make_all_subdirectories(file_backend);
                    fprintf(stdout, _("Finished !\n"));
                }
            free_variable(path);

        }
    else
        {
            print_error(__FILE__, __LINE__, _("Error: no serveur structure or no backend structure.\n"));
        }
}


/**
 * Allocates a newly buffer_t structure and fills it with the corresponding
 * values.
 * @param stream is the GFileInputStream stream from which we want to read things
 * @returns a newly allocated buffer_t structure with buf, size and pos
 *          filled accordingly. It may be freed when no longer needed.
 */
static buffer_t *init_buffer_structure(GFileInputStream *stream)
{
    buffer_t *a_buffer = NULL;
    gchar *buf = NULL;

    a_buffer = (buffer_t *) g_malloc0(sizeof(buffer_t));

    buf =(gchar *) g_malloc0(FILE_BACKEND_BUFFER_SIZE + 1); /* to store the \0 at the end ! */

    a_buffer->buf = buf;
    a_buffer->size = 0;
    a_buffer->pos = 0;
    a_buffer->stream = stream;

    return a_buffer;
}


/**
 * Frees the buffer structrure
 * @param a_buffer is the buffer structure to be freed
 */
static void free_buffer_t(buffer_t *a_buffer)
{
    free_variable(a_buffer->buf);
    g_object_unref(a_buffer->stream);
    free_variable(a_buffer);
}


/**
 * Reads one entire buffer
 * @param[in,out] a_buffer is a buffer_t * structure containing all that is
 *                needed to read a buffer and to know where we are in it
 *                when parsing it. It fills the structure with the bytes
 *                read, the number of bytes read and puts pos at 0.
 */
static void read_one_buffer(buffer_t *a_buffer)
{
    GError *error = NULL;

    if (a_buffer != NULL && a_buffer->stream != NULL)
        {
            a_buffer->size = g_input_stream_read((GInputStream *) a_buffer->stream, a_buffer->buf, FILE_BACKEND_BUFFER_SIZE, NULL, &error);
            a_buffer->pos = 0;

            if (a_buffer->size < 0 && error != NULL)
                {
                    print_error(__FILE__, __LINE__, _("Error while reading the file : %s\n"), error->message);
                    error = free_error(error);
                }
        }
}


/**
 * This function extracts one line from the buffer by searching the end of
 * line (assuming unix style '\n' end of lines).
 * @param[in,out] a_buffer contains the buffer the total number of bytes read
 *                and the actual position
 * @returns a gchar * representing a whole line that may be freed when no
 *          longer needed.
 */
static gchar *extract_one_line_from_buffer(buffer_t *a_buffer)
{
    gchar *line = NULL;
    gchar *a_line = NULL;
    gchar *whole_line = NULL;
    gssize i = 0;

    if (a_buffer != NULL && a_buffer->buf != NULL)
        {
            i = a_buffer->pos;

            while (a_buffer->buf[i] != '\n' && a_buffer->size != 0)
                {
                    if (i < a_buffer->size)
                        {
                            i++;
                        }
                    else
                        {
                            /* The line is stored in more than one buffer */

                            line = g_strndup(a_buffer->buf + a_buffer->pos, i - a_buffer->pos);

                            if (whole_line != NULL)
                                {
                                    /* the line is stored in more than 2 buffers */
                                    a_line = g_strconcat(whole_line, line, NULL);
                                    free_variable(whole_line);
                                    free_variable(line);
                                    whole_line = a_line;
                                }
                            else
                                {
                                    /* second buffer */
                                    whole_line = line;
                                }

                            read_one_buffer(a_buffer);
                            i = 0;
                        }
                }


            line = g_strndup(a_buffer->buf + a_buffer->pos, i - a_buffer->pos);
            a_buffer->pos = i + 1; /* the new position is right next '\n' ! */

            if (whole_line != NULL)
                {
                    a_line = g_strconcat(whole_line, line, NULL);
                    free_variable(whole_line);
                    free_variable(line);
                    whole_line = a_line;
                }
            else
                {
                    whole_line = line;
                }
        }

    return whole_line;
}


/**
 * @param string a gchar * string containing a number coded at most in 64
 *        bits.
 * @returns a guint64 from the gchar * string that may contain such a
 *          number.
 */
static guint64 get_guint64_from_string(gchar *string)
{
    guint64 guess_64 = 0;

    if (string != NULL)
        {
            sscanf(string, "%" G_GUINT64_FORMAT "", &guess_64);
        }

    return guess_64;
}


/**
 * @param string a gchar * string containing a number that should be
 *        32 bits at most.
 * @returns a uint from the gchar * string that may contain such a number.
 */
static uint get_uint_from_string(gchar *string)
{
    uint guess = 0;

    if (string != NULL)
        {
            sscanf(string, "%d", &guess);
        }

    return guess;
}


/**
 * Compares mtime to a YYYY-MM-DD HH:MM:SS gchar * string formated date
 * @param mtime the time in unix time
 * @param date the date in YYYY-MM-DD HH:MM:SS format - it may lack
 *        things from the end ie: YYYY-MM-DD HH: for instance.
 */
static gboolean compare_mtime_to_date(guint64 mtime, gchar *date)
{
    GDateTime *la_date = NULL;
    gchar *the_date = NULL;
    gboolean result = TRUE;

    if (date != NULL)
        {
            la_date = g_date_time_new_from_unix_local(mtime);
            the_date = g_date_time_format(la_date, "%F %T %z");

            result = g_str_has_prefix(the_date, date);

            free_variable(the_date);
            g_date_time_unref(la_date);
        }

    return result;
}



/**
 * Extracts all meta datas from one line.
 * @param line the line that has been read.
 * @param a_regex is the regular expression to filter upon the filename
 * @param query is the structure that contains everything about the
 *        requested filename.
 * @returns a newly allocated gchar * string containing the filename that
 *          may be freed when no longer needed
 */
static meta_data_t *extract_from_line(gchar *line, GRegex *a_regex, query_t *query)
{
    gchar **params = NULL;
    gchar *filename = NULL;
    meta_data_t *meta = NULL;
    guint32 q_uid = 0;
    guint32 q_gid = 0;


    if (line != NULL && strlen(line) > 16)
        {
            /**
             * line example : 1, 1049893, 33261, 1432131763, 1432129404, 1425592185, 38680, "root", "root", 0, 0, "/bin/locale", "eAAAdPN/AAAQFgB0838AAFNKQtsAlNrU4QHmJlkxiKA=",
             * "IBUAdPN/AADgCQB0838AACuk6dHfqsfcXvECD/HXSbU=", "4AwAdPN/AAAQFgB0838AAPJ18vuZ+mHsaFOztwu6IWw="
             */

            params = g_strsplit(line, ",", 14);
            /* we have a leading space before " and a trailing space after " so begins at + 2 and length is - 3 less */
            filename = g_strndup(params[11]+2, strlen(params[11])-3);

            if (g_regex_match(a_regex, filename, 0, NULL))
                {
                    meta = new_meta_data_t();

                    meta->name = filename;

                    meta->file_type = get_uint_from_string(params[0]);
                    meta->inode = get_guint64_from_string(params[1]);

                    meta->mode = get_uint_from_string(params[2]);

                    meta->atime = get_guint64_from_string(params[3]);
                    meta->ctime = get_guint64_from_string(params[4]);
                    meta->mtime = get_guint64_from_string(params[5]);

                    if (compare_mtime_to_date(meta->mtime, query->date))
                        {

                            meta->size = get_guint64_from_string(params[6]);

                            meta->owner = g_strndup(params[7]+2, strlen(params[7])-3);
                            meta->group = g_strndup(params[8]+2, strlen(params[8])-3);
                            meta->link = g_strndup(params[12]+2, strlen(params[12])-3);

                            meta->uid = get_uint_from_string(params[9]);
                            meta->gid = get_uint_from_string(params[10]);
                            q_uid = get_uint_from_string(query->uid);
                            q_gid = get_uint_from_string(query->gid);

                            if (strcmp(meta->owner, query->owner) == 0 && strcmp(meta->group, query->group) == 0 && (meta->uid == q_uid) && (meta->gid == q_gid))
                                {
                                    meta->hash_data_list = make_hash_data_list_from_string(params[13]);

                                    print_debug(_("file_backend: Found: type %d, inode: %ld, mode: %d, atime: %ld, ctime: %ld, mtime: %ld, size: %ld, filename: %s, owner: %s, group: %s, uid: %d, gid: %d, link: %s\n"), meta->file_type, meta->inode, meta->mode, meta->atime, meta->ctime, meta->mtime, meta->size, meta->name, meta->owner, meta->group, meta->uid, meta->gid, meta->link);
                                 }
                            else
                                {
                                    meta = free_meta_data_t(meta);
                                }
                        }
                    else
                        {
                             meta = free_meta_data_t(meta);
                        }
                }
            else
                {
                    free_variable(filename);
                }

            g_strfreev(params);
        }

    return meta;
}



/**
 * Gets the list of all saved files.
 * @param serveur_struct is the structure that contains all datas for the
 *        server.
 * @param query is the structure that contains everything about the
 *        requested query.
 * @returns a JSON string containing all filenames requested
 * @note g_str_match_string is only available since glib 2.40 and
 *       travis-ci.org has an older version of it!
 */
gchar *file_get_list_of_files(serveur_struct_t *serveur_struct, query_t *query)
{
    gchar *filename = NULL;
    file_backend_t *file_backend = NULL;
    GFile *the_file = NULL;
    GFileInputStream *stream = NULL;
    GError *error = NULL;
    buffer_t *a_buffer = NULL;
    gchar *line = NULL;
    json_t *array = NULL;
    json_t *root = NULL;
    gchar *json_string = NULL;
    GRegex *a_regex = NULL;
    meta_data_t *meta = NULL;
    json_t *meta_json = NULL;


    array = json_array();

    if (serveur_struct != NULL && serveur_struct->backend != NULL &&  serveur_struct->backend->user_data != NULL && query != NULL)
        {

            print_debug(_("file_backend: filter is: %s && %s\n"), query->filename, query->date);

            a_regex = g_regex_new(query->filename, G_REGEX_CASELESS, 0, &error);

            file_backend = serveur_struct->backend->user_data;
            filename =  g_build_filename(file_backend->prefix, "metas", query->hostname, NULL);
            the_file = g_file_new_for_path(filename);

            stream = g_file_read(the_file, NULL, &error);

            if (stream != NULL)
                {
                    a_buffer = init_buffer_structure(stream);
                    read_one_buffer(a_buffer);
                    do
                        {
                            line = extract_one_line_from_buffer(a_buffer);

                            if (a_buffer->size != 0)
                                {
                                    meta = extract_from_line(line, a_regex, query);

                                    if (meta != NULL && meta->name != NULL)
                                        {
                                            meta_json = convert_meta_data_to_json(meta, query->hostname);
                                            json_array_append_new(array, meta_json);
                                        }

                                    free_meta_data_t(meta);
                                }

                            free_variable(line);

                        }
                    while (a_buffer->size != 0);

                    g_input_stream_close((GInputStream *) stream, NULL, &error);

                    free_buffer_t(a_buffer);
                }
            else
                {
                     print_error(__FILE__, __LINE__, _("Error: unable to open file %s to read datas from it.\n"), filename);
                }

            free_variable(filename);
            g_regex_unref(a_regex);
        }
    else
        {
            print_debug(_("file_backend: Something is wrong with backend initialization!\n"));
        }

    root = json_object();
    insert_json_value_into_json_root(root, "file_list", array);
    json_string = json_dumps(root, 0);

    json_decref(array);
    json_decref(root);

    return json_string;
}


/**
 * Retrieves data from a flat file. The file is named by its hash in hex
 * representation (one should easily check that the sha256sum of such a
 * file gives its name !).
 * @param serveur_struct is the serveur main structure where all
 *        informations needed by the program are stored.
 * @param hex_hash is a gchar * hash in hexadecimal format as retrieved
 *        from the url.
 */
hash_data_t *file_retrieve_data(serveur_struct_t *serveur_struct, gchar *hex_hash)
{
    GFile *data_file = NULL;
    gchar *filename = NULL;
    GFileInputStream *stream = NULL;
    GError *error = NULL;
    gssize read = 0;
    gchar *path = NULL;
    gchar *prefix = NULL;
    file_backend_t *file_backend = NULL;
    hash_data_t *hash_data = NULL;
    guchar *data = NULL;
    guint8 *hash = NULL;
    guint64 filesize = 0;


    if (serveur_struct != NULL && serveur_struct->backend != NULL && serveur_struct->backend->user_data != NULL)
        {
            file_backend = serveur_struct->backend->user_data;
            prefix = g_build_filename((gchar *) file_backend->prefix, "datas", NULL);
            hash = string_to_hash(hex_hash);
            path = make_path_from_hash(prefix, hash, file_backend->level);
            filename = g_build_filename(path, hex_hash, NULL);
            data_file = g_file_new_for_path(filename);
            stream = g_file_read(data_file, NULL, &error);

            print_debug(_("file_backend: path: %s, filename: %s\n"), path, filename);

            if (stream != NULL)
                {
                    filesize = get_file_size(data_file);
                    /* we can do this because files may not be too big: as large as FILE_BACKEND_BUFFER_SIZE ? */
                    data = (guchar *) g_malloc0(filesize + 1);

                    read = g_input_stream_read((GInputStream *) stream, data, filesize, NULL, &error);

                    if (error != NULL)
                        {
                            print_error(__FILE__, __LINE__, _("Error: unable to read from file %s (%ld bytes read): %s.\n"), filename, read, error->message);
                            free_error(error);
                        }
                    else
                        {
                            hash_data = new_hash_data_t(data, read, hash);
                        }

                    g_input_stream_close((GInputStream *) stream, NULL, &error);
                    g_object_unref(stream);
                }
            else
                {
                     print_error(__FILE__, __LINE__, _("Error: unable to open file %s to read datas from it.\n"), filename);
                }

            free_object(data_file);
            free_variable(filename);
            free_variable(path);
            free_variable(prefix);
        }

    return hash_data;
}
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    serveur.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file serveur.h
 *
 * This file contains all the definitions of the functions and structures
 * that are used by 'serveur' Sauvegarde's server.
 * @todo add some stats structure that will keep some values about the
 *       activity of serveur server.
 */
#ifndef _SERVEUR_H_
#define _SERVEUR_H_

#include "config.h"

#define MHD_PLATFORM_H
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdint.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <microhttpd.h>
#include <glib.h>
#include <gio/gio.h>
#include <glib/gi18n-lib.h>
#include <sys/inotify.h>
#include <errno.h>
#include <math.h>

#include <libsauvegarde.h>

/**
 * @def SERVEUR_DATE
 * Defines serveur's creation date
 *
 * @def SERVEUR_AUTHORS
 * Defines serveur's main authors
 *
 * @def SERVEUR_LICENSE
 * Defines serveur's license (at least GPL v2)
 *
 * @def SERVEUR_VERSION
 * Defines serveur's version (which may be different of Sauvegarde's whole
 * project and programs that composes it).
 *
 * @def PROGRAM_NAME
 * Defines the main program name (serveur - server in french)
 */
#define SERVEUR_AUTHORS ("Olivier DELHOMME <olivier.delhomme@free.fr>")
#define SERVEUR_DATE _("15 08 2015")
#define SERVEUR_LICENSE _("GPL v3 or later")
#define SERVEUR_VERSION _("0.0.2")
#define PROGRAM_NAME ("serveur")

#include "options.h"
#include "backend.h"


/**
 * @struct serveur_struct_t
 * @brief Structure that contains everything needed by the program.
 *
 * This structure was named serveur_struct_t to avoid any confusion with
 * main_struct that is the structure for 'client' program (composed of
 * monitor, ciseaux and antememoire).
 */
typedef struct
{
    options_t *opt;           /**< Options of the program from the command line */
    struct MHD_Daemon *d;     /**< libmicrohttpd daemon structure               */
    backend_t *backend;
    GAsyncQueue *meta_queue;  /**< An asynchronous queue where smeta data will
                               *   be transmitted as it arrives                 */
    GAsyncQueue *data_queue;  /**< An asynchronous queue where data will be
                               *   transmitted as it arrives                    */
} serveur_struct_t;


#include "file_backend.h"


#endif /* #ifndef _SERVEUR_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    backend.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file serveur/backend.c
 *
 * This file contains all the functions for the backend management of
 * serveur's server.
 */

#include "serveur.h"


/**
 * Inits the backend with the correct functions
 * @todo write some backends !
 * @param store_smeta a function to store serveur meta data structure
 * @param store_data a function to store datas
 * @param init_backend a function to init the backend
 * @param build_needed_hash_list a function that must build a GSList * needed hash list
 * @param get_list_of_files gets the list of saved files
 * @param retrieve_data retrieves data from a specified hash.
 * @returns a newly created backend_t structure initialized to nothing !
 */
backend_t *init_backend_structure(void *store_smeta, void *store_data, void *init_backend, void *build_needed_hash_list, void *get_list_of_files, void * retrieve_data)
{
    backend_t *backend = NULL;

    backend = (backend_t *) g_malloc0(sizeof(backend_t));

    backend->user_data = NULL;
    backend->store_smeta = store_smeta;
    backend->store_data = store_data;
    backend->init_backend = init_backend;
    backend->build_needed_hash_list = build_needed_hash_list;
    backend->get_list_of_files = get_list_of_files;
    backend->retrieve_data = retrieve_data;

    return backend;
}


/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    serveur.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file serveur.c
 * This file contains all the stuff for the serveur program of "Sauvegarde"
 * project. The aim of this program is to save every checksum and data and
 * meta data of every 'client' program that is connected to.
 */

#include "serveur.h"

static serveur_struct_t *init_serveur_main_structure(int argc, char **argv);
static gchar *get_data_from_a_specific_hash(serveur_struct_t *serveur_struct, gchar *hash);
static gchar *get_argument_value_from_key(struct MHD_Connection *connection, gchar *key, gboolean encoded);
static gchar *get_a_list_of_files(serveur_struct_t *serveur_struct, struct MHD_Connection *connection);
static gchar *get_json_answer(serveur_struct_t *serveur_struct, struct MHD_Connection *connection, const char *url);
static gchar *get_unformatted_answer(serveur_struct_t *serveur_struct, const char *url);
static int process_get_request(serveur_struct_t *serveur_struct, struct MHD_Connection *connection, const char *url, void **con_cls);
static int answer_meta_json_post_request(serveur_struct_t *serveur_struct, struct MHD_Connection *connection, gchar *received_data);
static int process_received_data(serveur_struct_t *serveur_struct, struct MHD_Connection *connection, const char *url, gchar *received_data);
static int process_post_request(serveur_struct_t *serveur_struct, struct MHD_Connection *connection, const char *url, void **con_cls, const char *upload_data, size_t *upload_data_size);
static int print_out_key(void *cls, enum MHD_ValueKind kind, const char *key, const char *value);
static void print_headers(struct MHD_Connection *connection);
static int ahc(void *cls, struct MHD_Connection *connection, const char *url, const char *method, const char *version, const char *upload_data, size_t *upload_data_size, void **con_cls);
static gpointer meta_datas_thread(gpointer user_data);
static gpointer datas_thread(gpointer user_data);


/**
 * Inits main serveur's structure
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 * @returns a serveur_struct_t * structure that contains everything that is
 *          needed for 'serveur' program.
 */
static serveur_struct_t *init_serveur_main_structure(int argc, char **argv)
{
    serveur_struct_t *serveur_struct = NULL;  /** main structure for 'serveur' program. */

    serveur_struct = (serveur_struct_t *) g_malloc0(sizeof(serveur_struct_t));

    serveur_struct->opt = do_what_is_needed_from_command_line_options(argc, argv);
    serveur_struct->d = NULL;            /* libmicrohttpd daemon pointer */
    serveur_struct->meta_queue = g_async_queue_new();
    serveur_struct->data_queue = g_async_queue_new();

    /* default backend (file_backend) */
    serveur_struct->backend = init_backend_structure(file_store_smeta, file_store_data, file_init_backend, file_build_needed_hash_list, file_get_list_of_files, file_retrieve_data);

    return serveur_struct;
}


/**
 * Function that gets the data of a specific hash
 * @param serveur_struct is the main structure for the server.
 * @param hash is the hash (in hex format) of which we want the data.
 * @returns a json formatted string.
 */
static gchar *get_data_from_a_specific_hash(serveur_struct_t *serveur_struct, gchar *hash)
{
    gchar *answer = NULL;
    backend_t *backend = NULL;
    hash_data_t *hash_data = NULL;

    if (serveur_struct != NULL && serveur_struct->backend != NULL)
        {
            backend = serveur_struct->backend;

            if (backend->retrieve_data != NULL)
                {
                    hash_data = backend->retrieve_data(serveur_struct, hash);
                    answer = convert_hash_data_t_to_json(hash_data);
                    free_hash_data_t_structure(hash_data);

                    if (answer == NULL)
                        {
                            answer = g_strdup_printf("Error while trying to get data from hash %s", hash);
                        }
                }
            else
                {
                    answer = g_strdup(_("This backend's missing a retrieve_data function!"));
                }
        }
    else
        {
            answer = g_strdup(_("Something's wrong with server's initialisation!"));
        }

    return answer;
}


/**
 * Function that gets the argument corresponding to the key 'key' in the
 * url (from connection)
 * @param connection is the connection in MHD
 * @param key the key to look for into the url
 * @param encoded is a boolean that is TRUE if value is base64 encoded
 * @returns a gchar * string that may be freed when no longer needed
 */
static gchar *get_argument_value_from_key(struct MHD_Connection *connection, gchar *key, gboolean encoded)
{
    const char *value = NULL;
    gchar *value_dup = NULL;
    gsize len = 0;

    if (connection != NULL && key != NULL)
        {
            value = MHD_lookup_connection_value(connection, MHD_GET_ARGUMENT_KIND, key);

            if (value != NULL)
                {
                    if (encoded == TRUE)
                        {
                            value_dup = (gchar *) g_base64_decode(value, &len);
                        }
                    else
                        {
                            value_dup = g_strdup(value);
                        }
                }
        }

    return value_dup;
}


/**
 * Function to get a list of saved files.
 * @param serveur_struct is the main structure for the server.
 * @param connection is the connection in MHD
 * @param url is the requested url
 * @returns a json formatted string or NULL
 */
static gchar *get_a_list_of_files(serveur_struct_t *serveur_struct, struct MHD_Connection *connection)
{
    gchar *answer = NULL;
    gchar *hostname = NULL;
    gchar *uid = NULL;
    gchar *gid = NULL;
    gchar *owner = NULL;
    gchar *group = NULL;
    gchar *filename = NULL;
    gchar *date = NULL;
    backend_t *backend = NULL;
    query_t *query = NULL;


    if (serveur_struct != NULL && serveur_struct->backend != NULL)
        {
            backend = serveur_struct->backend;

            if (backend->get_list_of_files != NULL)
                {
                    hostname = get_argument_value_from_key(connection, "hostname", FALSE);
                    uid = get_argument_value_from_key(connection, "uid", FALSE);
                    gid = get_argument_value_from_key(connection, "gid", FALSE);
                    owner = get_argument_value_from_key(connection, "owner", FALSE);
                    group = get_argument_value_from_key(connection, "group", FALSE);
                    filename = get_argument_value_from_key(connection, "filename", TRUE);
                    date = get_argument_value_from_key(connection, "date", TRUE);

                    print_debug(_("hostname: %s, uid: %s, gid: %s, owner: %s, group: %s, filter: %s && %s\n"), hostname, uid, gid, owner, group, filename, date);

                    if (hostname != NULL && uid != NULL && gid != NULL && owner != NULL && group != NULL)
                        {
                            query = init_query_structure(hostname, uid, gid, owner, group, filename, date);
                            answer = backend->get_list_of_files(serveur_struct, query);
                            free_query_structure(query); /** All variables hostname, uid... are freed there ! */
                        }
                    else
                        {
                            answer = g_strdup_printf(_("Malformed request. hostname: %s, uid: %s, gid: %s, owner: %s, group: %s"), hostname, uid, gid, owner, group);
                            free_variable(hostname);
                            free_variable(uid);
                            free_variable(gid);
                            free_variable(owner);
                            free_variable(group);
                            free_variable(filename);
                            free_variable(date);
                        }
                }
        }

    return answer;
}


/**
 * Function to answer to get requests in a json way. This mode should be
 * prefered.
 * @param serveur_struct is the main structure for the server.
 * @param connection is the connection in MHD
 * @param url is the requested url
 * @note to translators all json requests MUST NOT be translated because
 *       it is the protocol itself !
 * @returns a newlly allocated gchar * string that contains the anwser to be
 *          sent back to the client.
 */
static gchar *get_json_answer(serveur_struct_t *serveur_struct, struct MHD_Connection *connection, const char *url)
{
    gchar *answer = NULL;
    gchar *hash = NULL;
    size_t hlen = 0;

    if (g_strcmp0(url, "/Version.json") == 0)
        {
            answer = convert_version_to_json(PROGRAM_NAME, SERVEUR_DATE, SERVEUR_VERSION, SERVEUR_AUTHORS, SERVEUR_LICENSE);
        }
    else if (g_str_has_prefix(url, "/File/List.json"))
        {
            answer = get_a_list_of_files(serveur_struct, connection);
        }
    else if (g_str_has_prefix(url, "/Data/"))
        {
            hash = g_strndup((const gchar *) url + 6, HASH_LEN*2);  /* HASH_LEN is expressed when hash is in binary form  */
            hash = g_strcanon(hash, "abcdef0123456789", '\0');      /* replace anything not in hexadecimal format with \0 */

            hlen = strlen(hash);
            if (hlen == HASH_LEN*2)
                {
                    print_debug(_("Trying to get data for hash %s\n"), hash);
                    answer = get_data_from_a_specific_hash(serveur_struct, hash);
                }
            else
                {
                    answer = g_strdup_printf("{\"Invalid url: in %s hash has length\": %zd instead of %d}", url, hlen, HASH_LEN*2);
                }

            free_variable(hash);
        }
    else
        { /* Some sort of echo to the invalid request */
            answer = g_strdup_printf("{\"Invalid url\": %s}", url);
        }

    return answer;
}


/**
 * Function to answer to get requests in an unformatted way. Only some urls
 * May be like this. As we prefer to speak in json format in normal operation
 * mode
 * @param serveur_struct is the main structure for the server.
 * @param url is the requested url
 * @returns a newlly allocated gchar * string that contains the anwser to be
 *          sent back to the client.
 */
static gchar *get_unformatted_answer(serveur_struct_t *serveur_struct, const char *url)
{
    gchar *answer = NULL;
    gchar *buf1 = NULL;
    gchar *buf2 = NULL;
    gchar *buf3 = NULL;

    if (g_strcmp0(url, "/Version") == 0)
        {
            buf1 = buffer_program_version(PROGRAM_NAME, SERVEUR_DATE, SERVEUR_VERSION, SERVEUR_AUTHORS, SERVEUR_LICENSE);
            buf2 = buffer_libraries_versions(PROGRAM_NAME);
            buf3 = buffer_selected_option(serveur_struct->opt);

            answer = g_strconcat(buf1, buf2, buf3, NULL);

            buf1 = free_variable(buf1);
            buf2 = free_variable(buf2);
            buf3 = free_variable(buf3);
        }
    else
        { /* Some sort of echo to the invalid request */
            answer = g_strdup_printf(_("Error: invalid url: %s\n"), url);
        }

    return answer;
}


/**
 * Function to process get requests received from clients.
 * @param serveur_struct is the main structure for the server.
 * @param connection is the connection in MHD
 * @param url is the requested url
 * @param con_cls is a pointer used to know if this is the first call or not
 * @returns an int that is either MHD_NO or MHD_YES upon failure or not.
 */
static int process_get_request(serveur_struct_t *serveur_struct, struct MHD_Connection *connection, const char *url, void **con_cls)
{
    static int aptr = 0;
    int success = MHD_NO;
    gchar *answer = NULL;
    struct MHD_Response *response = NULL;


    if (&aptr != *con_cls)
        {
            /* do never respond on first call */
            *con_cls = &aptr;

            success = MHD_YES;
        }
    else
        {
            if (get_debug_mode() == TRUE)
                {
                    print_debug(_("Requested get url: %s\n"), url);
                    print_headers(connection);
                }

            if (g_str_has_suffix(url, ".json"))
                { /* A json format answer was requested */
                    answer = get_json_answer(serveur_struct, connection, url);
                }
            else
                { /* An "unformatted" answer was requested */
                    answer = get_unformatted_answer(serveur_struct, url);
                }

                /* reset when done */
                *con_cls = NULL;

                /* Do not free answer variable as MHD will do it for us ! */
                response = MHD_create_response_from_buffer(strlen(answer), (void *) answer, MHD_RESPMEM_MUST_FREE);
                success = MHD_queue_response(connection, MHD_HTTP_OK, response);

                MHD_destroy_response(response);

        }

    return success;

}


/**
 * Answers /Meta.json POST request by storing datas and answering to the
 * client.
 * @param serveur_struct is the main structure for the server.
 * @param connection is the connection in MHD
 * @param received_data is a gchar * string to the data that was received
 *        by the POST request.
 */
static int answer_meta_json_post_request(serveur_struct_t *serveur_struct, struct MHD_Connection *connection, gchar *received_data)
{
    struct MHD_Response *response = NULL;
    serveur_meta_data_t *smeta = NULL;
    gchar *answer = NULL;                   /** gchar *answer : Do not free answer variable as MHD will do it for us ! */
    int success = MHD_NO;
    json_t *root = NULL;        /** json_t *root is the root that will contain all meta data json formatted */
    json_t *array = NULL;       /** json_t *array is the array that will receive base64 encoded hashs       */
    gchar *json_str = NULL;     /** gchar *json_str is the string to be returned at the end                 */
    GSList *needed = NULL;

    smeta = convert_json_to_smeta_data(received_data);

    if (smeta != NULL && smeta->meta != NULL)
        {   /* The convertion went well and smeta contains the meta datas */

            print_debug(_("Received meta datas for file %s\n"), smeta->meta->name);

            /**
             * Creating an answer and sending the hashs that are needed. If
             * the selected backend does not have a build_needed_hash_list
             * function we are returning the whole hash_list !
             */

            if (serveur_struct != NULL && serveur_struct->backend != NULL && serveur_struct->backend->build_needed_hash_list != NULL)
                {
                    needed = serveur_struct->backend->build_needed_hash_list(serveur_struct, smeta->meta->hash_data_list);
                    array = convert_hash_list_to_json(needed);
                    needed = free_list(needed);
                }
            else
                {
                    array = convert_hash_list_to_json(smeta->meta->hash_data_list);
                }

            root = json_object();
            insert_json_value_into_json_root(root, "hash_list", array);
            json_str = json_dumps(root, 0);
            json_decref(root);

            /**
             * Sending smeta datas into the queue in order to be treated by
             * the corresponding thread. smeta is freed there and should not
             * be used after this "call" here.
             */
            g_async_queue_push(serveur_struct->meta_queue, smeta);

            response = MHD_create_response_from_buffer(strlen(json_str), (void *) json_str, MHD_RESPMEM_MUST_FREE);
            success = MHD_queue_response(connection, MHD_HTTP_OK, response);
        }
    else
        {
            answer = g_strdup_printf(_("Error: could not convert json to metadata\n"));
            response = MHD_create_response_from_buffer(strlen(answer), (void *) answer, MHD_RESPMEM_MUST_FREE);
            success = MHD_queue_response(connection, MHD_HTTP_OK, response);
        }

    MHD_destroy_response(response);

    return success;

}


/**
 * Function that process the received data from the POST command and
 * answers to the client.
 * Here we may do something with this data (we may want to store it
 * somewhere).
 *
 * @param serveur_struct is the main structure for the server.
 * @param connection is the connection in MHD
 * @param url is the requested url
 * @param received_data is a gchar * string to the data that was received
 *        by the POST request.
 */
static int process_received_data(serveur_struct_t *serveur_struct, struct MHD_Connection *connection, const char *url, gchar *received_data)
{
    struct MHD_Response *response = NULL;
    gchar *answer = NULL;                   /** gchar *answer : Do not free answer variable as MHD will do it for us ! */
    int success = MHD_NO;
    gchar *encoded_hash = NULL;
    hash_data_t *hash_data = NULL;

    if (g_strcmp0(url, "/Meta.json") == 0 && received_data != NULL)
        {
            success = answer_meta_json_post_request(serveur_struct, connection, received_data);
        }
    else if (g_strcmp0(url, "/Data.json") == 0 && received_data != NULL)
        {

            hash_data = convert_json_to_hash_data(received_data);

            encoded_hash = g_base64_encode(hash_data->hash, HASH_LEN);
            print_debug(_("Received data for hash: \"%s\" (%ld bytes)\n"), encoded_hash, hash_data->read);
            free_variable(encoded_hash);

            /**
             * Sending received_data into the queue in order to be treated by
             * the corresponding thread. hash_data is freed by datas_thread
             * and should not be used after this "call" here.
             */
            g_async_queue_push(serveur_struct->data_queue, hash_data);


            /**
             * creating an answer for the client to say that everything went Ok!
             */
            answer = g_strdup_printf(_("Ok!"));
            response = MHD_create_response_from_buffer(strlen(answer), (void *) answer, MHD_RESPMEM_MUST_FREE);
            success = MHD_queue_response(connection, MHD_HTTP_OK, response);
            MHD_destroy_response(response);
        }
    else
        {
            /* The url is unknown to the server and we can not process the request ! */
            print_error(__FILE__, __LINE__, "Error: invalid url: %s\n", url);
            answer = g_strdup_printf(_("Error: invalid url!\n"));
            response = MHD_create_response_from_buffer(strlen(answer), (void *) answer, MHD_RESPMEM_MUST_FREE);
            success = MHD_queue_response(connection, MHD_HTTP_OK, response);
            MHD_destroy_response(response);
        }

    return success;
}


/**
 * Function to process post requests.
 * @param serveur_struct is the main structure for the server.
 * @param connection is the connection in MHD
 * @param url is the requested url
 * @param con_cls is a pointer used to know if this is the first call or not
 * @param upload_data is a char * pointer to the data being uploaded at this call
 * @param upload_size is a pointer to an size_t value that says how many data
 *        is ti be copied from upload_data string.
 * @returns an int that is either MHD_NO or MHD_YES upon failure or not.
 */
static int process_post_request(serveur_struct_t *serveur_struct, struct MHD_Connection *connection, const char *url, void **con_cls, const char *upload_data, size_t *upload_data_size)
{
    int success = MHD_NO;
    gchar *pp = *con_cls;
    gchar *newpp = NULL;
    gchar *received_data = NULL;
    gchar *buf1 = NULL;

    /* print_debug("%ld, %s, %p\n", *upload_data_size, url, pp); */  /* This is for early debug only ! */

    if (pp == NULL)
        {
            /* Initialzing the structure at first connection */
            pp = g_strdup("");
            *con_cls = pp;

            success = MHD_YES;
        }
    else if (*upload_data_size != 0)
        {
            /* Getting datas whatever they are */
            buf1 = g_strndup(upload_data, *upload_data_size);
            newpp = g_strconcat(pp, buf1, NULL);
            buf1 = free_variable(buf1);
            pp = free_variable(pp);

            *con_cls = newpp;

            *upload_data_size = 0;

            success = MHD_YES;
        }
    else
        {
            /* reset when done */
            *con_cls = NULL;

            received_data = g_strdup(pp);
            pp = free_variable(pp);

            /* Do something with received_data */
            success = process_received_data(serveur_struct, connection, url, received_data);

            free_variable(received_data);
        }

    return success;
}


/**
 * Prints all keys-values pairs contained in an HTTP header.
 * @param cls cls may be NULL here (not used).
 * @param[in] kind is the MHD_ValueKind requested
 * @param[in] key is the key to be printed
 * @param[in] value is the value of the corresponding key
 *
 */
static int print_out_key(void *cls, enum MHD_ValueKind kind, const char *key, const char *value)
{
  fprintf(stdout, "\t%s: %s\n", key, value);

  return MHD_YES;
}


/**
 * Prints everything in the header of a connection
 * @param connection the connection that we want to print all headers.
 */
static void print_headers(struct MHD_Connection *connection)
{
    fprintf(stdout, _("Headers for this connection are:\n"));
    MHD_get_connection_values(connection, MHD_HEADER_KIND, &print_out_key, NULL);
}


/**
 * MHD_AccessHandlerCallback function that manages all connections requests
 * @param cls is the serveur_struct_t * serveur_struct main serveur
 *        structure.
 * @todo . free some memory where needed
 *       . manage errors codes
 */
static int ahc(void *cls, struct MHD_Connection *connection, const char *url, const char *method, const char *version, const char *upload_data, size_t *upload_data_size, void **con_cls)
{
    serveur_struct_t *serveur_struct = (serveur_struct_t *) cls;
    int success = MHD_NO;


    if (g_strcmp0(method, "GET") == 0)
        {
            /* We have a GET method that needs to be processed */
            success = process_get_request(serveur_struct, connection, url, con_cls);
        }
    else if (g_strcmp0(method, "POST") == 0)
        {  /* We have a POST method that needs to be processed */
            success = process_post_request(serveur_struct, connection, url, con_cls, upload_data, upload_data_size);
        }
    else
        { /* not a GET nor a POST -> we do not know what to do ! */
            success = MHD_NO;
        }

    return success;
}


/**
 * Thread whose aim is to store meta-data according to the selected backend
 * @param data : serveur_struct_t * structure.
 * @returns NULL to fullfill the template needed to create a GThread
 */
static gpointer meta_datas_thread(gpointer user_data)
{
    serveur_struct_t *serveur_struct = user_data;
    serveur_meta_data_t *smeta = NULL;

    if (serveur_struct != NULL && serveur_struct->meta_queue != NULL)
        {

            if (serveur_struct->backend != NULL && serveur_struct->backend->store_smeta != NULL)
                {

                    while (TRUE)
                        {
                            smeta = g_async_queue_pop(serveur_struct->meta_queue);

                            if (smeta != NULL)
                                {
                                    print_debug("meta_data_thread: received from %s meta for file %s\n", smeta->hostname, smeta->meta->name);
                                    serveur_struct->backend->store_smeta(serveur_struct, smeta);
                                    free_smeta_data_t(smeta);
                                }
                            else
                                {
                                    print_error(__FILE__, __LINE__, _("Error: received a NULL pointer.\n"));
                                }
                        }
                }
            else
                {
                    print_error(__FILE__, __LINE__, _("Error: no meta data store backend defined, meta-datas's thread terminating...\n"));
                }
        }
    else
        {
            print_error(__FILE__, __LINE__, _("Error: unable to launch meta-data thread.\n"));
        }

    return NULL;
}


/**
 * Thread whose aim is to store datas according to the selected backend
 * @param data : serveur_struct_t * structure.
 * @returns NULL to fullfill the template needed to create a GThread
 */
static gpointer datas_thread(gpointer user_data)
{
    serveur_struct_t *serveur_struct = user_data;
    hash_data_t *hash_data = NULL;

    if (serveur_struct != NULL && serveur_struct->meta_queue != NULL)
        {

            if (serveur_struct->backend != NULL && serveur_struct->backend->store_data != NULL)
                {

                    while (TRUE)
                        {
                            hash_data = g_async_queue_pop(serveur_struct->data_queue);

                            if (hash_data != NULL)
                                {
                                    serveur_struct->backend->store_data(serveur_struct, hash_data);
                                }
                        }
                }
            else
                {
                    print_error(__FILE__, __LINE__, _("Error: no data store backend defined, datas's thread terminating...\n"));
                }

        }
    else
        {
            print_error(__FILE__, __LINE__, _("Error while trying to launch data thread"));
        }

    return NULL;
}


/**
 * Main function
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 * @returns always 0
 */
int main(int argc, char **argv)
{
    serveur_struct_t *serveur_struct = NULL;  /** main structure for 'serveur' program.            */
    GThread *data_thread = NULL;              /** Thread that will take care of storing meta datas */
    GThread *meta_thread = NULL;              /** Thread that will take care of storing datas      */


    #if !GLIB_CHECK_VERSION(2, 36, 0)
        g_type_init();  /** g_type_init() is deprecated since glib 2.36 */
    #endif

    ignore_sigpipe(); /** into order to get libmicrohttpd portable */

    init_international_languages();

    serveur_struct = init_serveur_main_structure(argc, argv);


    if (serveur_struct != NULL && serveur_struct->opt != NULL && serveur_struct->backend != NULL)
        {
            /* Initializing the choosen backend by calling it's function */
            if (serveur_struct->backend->init_backend != NULL)
                {
                   serveur_struct->backend->init_backend(serveur_struct);
                }

            /* Before starting anything else, start the threads */
            meta_thread = g_thread_new("meta-datas", meta_datas_thread, serveur_struct);
            data_thread = g_thread_new("datas", datas_thread, serveur_struct);

            /* Starting the libmicrohttpd daemon */
            serveur_struct->d = MHD_start_daemon(MHD_USE_THREAD_PER_CONNECTION | MHD_USE_DEBUG, serveur_struct->opt->port, NULL, NULL, &ahc, serveur_struct, MHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 120, MHD_OPTION_END);

            if (serveur_struct->d == NULL)
                {
                    print_error(__FILE__, __LINE__, _("Error while spawning libmicrohttpd daemon\n"));
                    return 1;
                }

            /* Unless on error we will never join the threads as they
             * contain a while (TRUE) loop !
             */
            g_thread_join(meta_thread);
            g_thread_join(data_thread);
            MHD_stop_daemon(serveur_struct->d);
        }
    else
        {
            print_error(__FILE__, __LINE__, _("Error: initialization failed.\n"));
        }

    return 0;
}
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    options.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file serveur/options.c
 *
 *  This file contains all the functions to manage command line options for
 *  'serveur' program.
 */

#include "serveur.h"

static void print_selected_options(options_t *opt);
static void read_from_configuration_file(options_t *opt, gchar *filename);
static void read_from_group_serveur(options_t *opt, GKeyFile *keyfile, gchar *filename);

/**
 * Frees the options structure if necessary.
 * @param opt : the malloc'ed options_t structure
 */
void free_options_t_structure(options_t *opt)
{

    if (opt != NULL)
        {
            free_variable(opt);
        }

}


/**
 * Prints options as selected when invoking the program with -v option
 * @param opt the options_t * structure that contains all selected options
 *        from the command line and that will be used by the program.
 */
static void print_selected_options(options_t *opt)
{
    if (opt != NULL)
        {
            fprintf(stdout, _("\n%s options are :\n"), PROGRAM_NAME);

            print_string_option(_("Configuration file : %s\n"), opt->configfile);

            if (opt->port != 0)
                {
                    fprintf(stdout, _("Port number : %d\n"), opt->port);
                }
        }
}

/**
 * creates a buffer containing every selected options ...
 * @param opt the options_t * structure that contains all selected options
 *        from the command line and that will be used by the program.
 * @returns options as selected when invoking the program with -v option
 * into a newly allocated buffer that may be freed when no longer needed
 */
gchar *buffer_selected_option(options_t *opt)
{
    gchar *buf1 = NULL;
    gchar *buffer = NULL;

    if (opt != NULL)
        {
            if (opt->configfile != NULL)
                {
                    buffer = g_strdup_printf(_("\n%s options are :\nConfiguration file : %s\n"), PROGRAM_NAME, opt->configfile);
                }
            else
                {
                    buffer = g_strdup_printf(_("\n%s options are :\n"), PROGRAM_NAME);
                }

            if (opt->port != 0)
                {
                    buf1 = g_strdup_printf(_("%sPort number : %d\n"), buffer, opt->port);
                    free_variable(buffer);
                    buffer = buf1;
                }
        }

    return buffer;
}


/**
 * Reads keys in keyfile if groupname is in that keyfile and fills
 * options_t *opt structure accordingly.
 * @param[in,out] opt : options_t * structure to store options read from the
 *                configuration file "filename".
 * @param keyfile is the GKeyFile structure that is used by glib to read
 *        groups and keys from.
 * @param filename : the filename of the configuration file to read from
 */
static void read_from_group_serveur(options_t *opt, GKeyFile *keyfile, gchar *filename)
{
    gboolean debug = FALSE;

    if (opt != NULL && keyfile != NULL && filename != NULL && g_key_file_has_group(keyfile, GN_SERVEUR) == TRUE)
        {
            /* Reading the port number if any */
            opt->port = read_int_from_file(keyfile, filename, GN_SERVEUR, KN_SERVEUR_PORT, _("Could not load serveur port number from file."));

            debug = read_boolean_from_file(keyfile, filename, GN_ALL, KN_DEBUG_MODE, _("Could not load debug mode configuration from file."));

            set_debug_mode(debug);
        }
}


/**
 * Reads from the configuration file "filename"
 * @param[in,out] opt : options_t * structure to store options read from the
 *                configuration file "filename"
 * @param filename : the filename of the configuration file to read from
 */
static void read_from_configuration_file(options_t *opt, gchar *filename)
{
    GKeyFile *keyfile = NULL;      /** Configuration file parser */
    GError *error = NULL;          /** Glib error handling       */

    if (filename != NULL)
        {
            if (opt->configfile != NULL)
                {
                    free_variable(opt->configfile);
                }

            opt->configfile = g_strdup(filename);

            print_debug(_("Reading configuration from file %s\n"), filename);

            keyfile = g_key_file_new();

            if (g_key_file_load_from_file(keyfile, filename, G_KEY_FILE_KEEP_COMMENTS, &error))
                {
                    read_from_group_serveur(opt, keyfile, filename);
                }
            else if (error != NULL)
                {
                    print_error(__FILE__, __LINE__,  _("Failed to open %s configuration file : %s\n"), filename, error->message);
                    error = free_error(error);
                }

            g_key_file_free(keyfile);
        }
}


/**
 * This function parses command line options. It sets the options in this
 * order. It means that the value used for an option is the one set in the
 * lastest step.
 * 0) default values are set into the options_t * structure
 * 1) reads the default configuration file if any.
 * 2) reads the configuration file mentionned on the command line.
 * 3) sets the command line options (except for the list of directories,
 *    all other values are replaced by thoses in the command line)
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 * @returns options_t structure malloc'ed and filled upon choosen command
 *          line's option
 */
options_t *manage_command_line_options(int argc, char **argv)
{
    gboolean version = FALSE;       /** True if -v was selected on the command line                                        */
    gint cmdl_debug = -4;           /** debug mode as specified on the command line                                        */
    gchar *configfile = NULL;       /** Filename for the configuration file if any                                         */
    gint port = 0;                  /** Port number on which to listen                                                     */

    GOptionEntry entries[] =
    {
        { "version", 'v', 0, G_OPTION_ARG_NONE, &version, N_("Prints program version."), NULL},
        { "debug", 'd', 0,  G_OPTION_ARG_INT, &cmdl_debug, N_("Activates (1) or desactivates (0) debug mode."), N_("BOOLEAN")},
        { "configuration", 'c', 0, G_OPTION_ARG_STRING, &configfile, N_("Specify an alternative configuration file."), N_("FILENAME")},
        { "port", 'p', 0, G_OPTION_ARG_INT, &port, N_("Port NUMBER on which to listen."), N_("NUMBER")},
        { NULL }
    };

    GError *error = NULL;
    GOptionContext *context;
    options_t *opt = NULL;    /** Structure to manage program's options            */
    gchar *bugreport = NULL;  /** Bug Report message                               */
    gchar *summary = NULL;    /** Abstract for the program                         */
    gchar *defaultconfigfilename = NULL;

    bugreport = g_strconcat(_("Please report bugs to: "), PACKAGE_BUGREPORT, NULL);
    summary = g_strdup(_("This program is monitoring file changes in the filesystem and is hashing\nfiles with SHA256 algorithms from Glib."));
    context = g_option_context_new("");

    set_debug_mode(ENABLE_DEBUG);

    set_option_context_options(context, entries, TRUE, bugreport, summary);

    if (!g_option_context_parse(context, &argc, &argv, &error))
        {
            g_print(_("[%s, %d] Option parsing failed: %s\n"),  __FILE__, __LINE__, error->message);
            exit(EXIT_FAILURE);
        }

    /* 0) Setting default values */

    opt = (options_t *) g_malloc0(sizeof(options_t));

    opt->configfile = NULL;
    opt->port = 5468;


    /* 1) Reading options from default configuration file */
    defaultconfigfilename = get_probable_etc_path(PROGRAM_NAME, "serveur.conf");
    read_from_configuration_file(opt,  defaultconfigfilename);
    free_variable(defaultconfigfilename);

    opt->version = version; /* only TRUE if -v or --version was invoked */

    if (cmdl_debug == 0)
        {
            set_debug_mode(FALSE);
        }
    else if (cmdl_debug == 1)
        {
            set_debug_mode(TRUE);
        }

    /* 2) Reading the configuration from the configuration file specified
     *    on the command line
     */
    if (configfile != NULL)
        {
            read_from_configuration_file(opt, configfile);
        }


    /* 3) retrieving other options from the command line.
     */

    if (port > 1024 && port < 65535)
        {
            opt->port = port;
        }

    g_option_context_free(context);
    free_variable(bugreport);
    free_variable(summary);

    return opt;
}


/**
 * Decides what to do upon command lines options passed to the program
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 * @returns options_t structure malloc'ed and filled upon choosen command
 *          line's option (in manage_command_line_options function).
 */
options_t *do_what_is_needed_from_command_line_options(int argc, char **argv)
{
    options_t *opt = NULL;  /** Structure to manage options from the command line can be freed when no longer needed */

    opt = manage_command_line_options(argc, argv);

    if (opt != NULL)
        {
            if (opt->version == TRUE)
                {
                    print_program_version(PROGRAM_NAME, SERVEUR_DATE, SERVEUR_VERSION, SERVEUR_AUTHORS, SERVEUR_LICENSE);
                    print_libraries_versions(PROGRAM_NAME);
                    print_selected_options(opt);
                    exit(EXIT_SUCCESS);
                }
        }

    return opt;
}


/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    file_backend.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file serveur/file_backend.h
 *
 * This file contains all definition for the functions for the file backend
 * system.
 */

#ifndef _SERVEUR_FILE_BACKEND_H_
#define _SERVEUR_FILE_BACKEND_H_


/**
 * @def FILE_BACKEND_BUFFER_SIZE
 * Defines the buffer size used to read files in the file_backend backend.
 * Should be at least as big as CISEAUX_BLOCK_SIZE
 */
#define FILE_BACKEND_BUFFER_SIZE 32768


/**
 * @struct file_backend_t
 * @brief Structure that contains everything needed by file backend.
 *
 * This structure contains the prefix for the path where datas are located.
 * and a level that indicates the number of level of directories
 * indirections. Default value is 2 but 3 or 4 may be used.
 * A level of 2 with a block size of 16384 bytes should be sufficient
 * to store up to 512 Gbytes of deduplicated data. A level of 3 should be
 * ok up to 256 tera bytes of deduplicated data. A level of 4 should be ok
 * for up to 65536 tera bytes !
 */
typedef struct
{
    gchar *prefix; /**< Prefix for the path where data are located */
    guint level;   /**< level of directories defaults to 3 */
} file_backend_t;



/**
 * @struct buffer_t
 * @brief used to know where we are in the buffer when extracting lines of
 *        it.
 */
typedef struct
{
    GFileInputStream *stream;   /**< Stream from which we want to read things */
    gssize pos;                 /**< Position into the buffer                 */
    gssize size;                /**< number of bytes read into the buffer     */
    gchar *buf;                 /**< buffer read                              */
} buffer_t;



/**
 * Stores meta data into a flat file. A file is created for each host that
 * sends meta datas. This code is not thread safe (it means that this is
 * not safe to call it from different threads unless some mechanism
 * garantees that a write will never occur in the same file at the same
 * time.
 * @param serveur_struct is the serveur main structure where all
 *        informations needed by the program are stored.
 * @param smeta the serveur structure for file meta data. It contains the
 *        hostname that sent it. This structure MUST be freed by this
 *        function.
 */
extern void file_store_smeta(serveur_struct_t *serveur_struct, serveur_meta_data_t *smeta);


/**
 * Inits the backend : takes care of the directories we want to write to.
 * user_data of the backend structure is a gchar * that represents the
 * prefix path where to store datas.
 * @param serveur_struct is the serveur main structure where all
 *        informations needed by the program are stored.
 */
extern void file_init_backend(serveur_struct_t *serveur_struct);


/**
 * Stores data into a flat file. The file is named by its hash in hex
 * representation (one should easily check that the sha256sum of such a
 * file gives its name !).
 * @param serveur_struct is the serveur main structure where all
 *        informations needed by the program are stored.
 * @param hash_data is a hash_data_t * structure that contains the hash and
 *        the corresponding data in a binary form and a 'read' field that
 *        contains the number of bytes in 'data' field.
 */
extern void file_store_data(serveur_struct_t *serveur_struct, hash_data_t *hash_data);


/**
 * Builds a list of hashs that serveur's server need.
 * @param serveur_struct is the serveur main structure where all
 *        informations needed by the program are stored.
 * @param hash_list is the list of hashs that we have to check for.
 */
extern GSList *file_build_needed_hash_list(serveur_struct_t *serveur_struct, GSList *hash_list);


/**
 * Gets the list of all saved files
 * @param serveur_struct is the structure that contains all datas for the
 *        server.
 * @param query is the structure that contains everything about the
 *        requested query.
 * @returns a JSON string containing all filenames requested
 */
extern gchar *file_get_list_of_files(serveur_struct_t *serveur_struct, query_t *query);


/**
 * Retrieves data from a flat file. The file is named by its hash in hex
 * representation (one should easily check that the sha256sum of such a
 * file gives its name !).
 * @param serveur_struct is the serveur main structure where all
 *        informations needed by the program are stored.
 * @param hex_hash is a gchar * hash in hexadecimal format as retrieved
 *        from the url.
 */
extern hash_data_t *file_retrieve_data(serveur_struct_t *serveur_struct, gchar *hex_hash);

#endif /* #ifndef _SERVEUR_FILE_BACKEND_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    options.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file monitor/options.h
 *
 *  This file contains all the definitions for the options of the command
 *  line.
 */
#ifndef _OPTIONS_H_
#define _OPTIONS_H_

/**
 * @struct options_t
 * @brief Selected options.
 *
 * Structure Options gives a way to store program options passed from the
 * command line or read from a configuration file.
 */
typedef struct
{
    gboolean version;     /**< TRUE if we have to display program's version                                      */
    GSList *dirname_list; /**< Directory names that were left in the command line                                */
    gint64 blocksize;     /**< block size in bytes                                                               */
    gchar *configfile;    /**< filename for the configuration file specified on the command line                 */
    gboolean noprint;     /**< FALSE by default, TRUE if we want to quiet the program while calculating checsums */
    gchar *dircache;      /**< Directory where we will cache files and temporary stuff to do the job             */
    gchar *dbname;        /**< File name of the database that is used to cache files and buffers localy          */
    gchar *ip;            /**< A string representing the IP address where serveur is located (may be a hotsname) */
    gint port;            /**< Port number on which to send things to serveur's server (on which it must listen) */
} options_t;


/**
 * This function parses command line options.
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 */
extern options_t *manage_command_line_options(int argc, char **argv);


/**
 * Frees the options structure if necessary
 * @param opt : the malloc'ed options_t structure
 */
extern void free_options_t_structure(options_t *opt);


/**
 * Decides what to do upon command lines options passed to the program
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 * @returns options_t structure malloc'ed and filled upon choosen command
 *          line's option (in manage_command_line_options function).
 */
extern options_t *do_what_is_needed_from_command_line_options(int argc, char **argv);


#endif /* #IFNDEF _OPTIONS_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    m_fanotify.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file m_fanotify.c
 *
 * This file does fanotify's monitor interface. This file is heavily based
 * on Aleksander Morgado fanotify-example.c's file (ie mainly copied !)
 * @todo : do something with the ugly code of this file (testing things for
 *         now - but should not be like that after tests).
 */

#include "monitor.h"

static gchar *get_file_path_from_fd(gint fd);
static char *get_program_name_from_pid(int pid);
static void event_process(main_struct_t *main_struct, struct fanotify_event_metadata *event, GSList *dir_list);


/**
 * Stops signal handling
 */
void  stop_signals(int signal_fd)
{
    close(signal_fd);
}


/**
 * Starts signal handling
 */
gint start_signals(void)
{
    gint signal_fd = -1;
    sigset_t sigmask;

      /* We want to handle SIGINT and SIGTERM in the signal_fd, so we block them. */
    sigemptyset(&sigmask);
    sigaddset(&sigmask, SIGINT);
    sigaddset(&sigmask, SIGTERM);

    if (sigprocmask(SIG_BLOCK, &sigmask, NULL) < 0)
        {
            print_error(__FILE__, __LINE__, _("Couldn't block signals: %s\n"), strerror(errno));
        }

      /* Get new FD to read signals from it */
    if ((signal_fd = signalfd(-1, &sigmask, 0)) < 0)
        {
            print_error(__FILE__, __LINE__, _("Couldn't setup signal FD: %s\n"), strerror(errno));
        }

  return signal_fd;
}


/**
 * Inits and starts fanotify notifications
 * @param opt : a filled options_t * structure that contains all options
 *        by default, read into the file or selected in the command line.
 */
gint start_fanotify(options_t *opt)
{
    gint fanotify_fd = -1;
    GSList *head = NULL;

    /** Leaving only FAN_CLOSE_WRITE for some tests */
    /* Setup fanotify notifications (FAN) mask. All these defined in linux/fanotify.h. */
    static uint64_t event_mask =
      (FAN_CLOSE_WRITE   |      /* Writtable file closed                                      */
       FAN_ONDIR         |      /* We want to be reported of events in the directory          */
       FAN_EVENT_ON_CHILD);     /* We want to be reported of events in files of the directory */

    unsigned int mark_flags = FAN_MARK_ADD | FAN_MARK_MOUNT;

    if (opt != NULL)
        {
            /* Create new fanotify device */
            if ((fanotify_fd = fanotify_init(FAN_CLOEXEC, O_RDONLY | O_CLOEXEC | O_LARGEFILE)) < 0)
                {
                    print_error(__FILE__, __LINE__, _("Couldn't setup new fanotify device: %s\n"), strerror(errno));
                }
            else
                {
                    head = opt->dirname_list;

                    while (head != NULL)
                        {
                            if (fanotify_mark(fanotify_fd, mark_flags, event_mask, AT_FDCWD, head->data) < 0)
                                {
                                  print_error(__FILE__, __LINE__, _("Couldn't add monitor in directory %s: %s\n"), head->data , strerror(errno));
                                }
                            else
                                {
                                    print_debug(_("Started monitoring directory %s\n"), head->data);
                                }

                            head = g_slist_next(head);
                        }
                }
        }

    return fanotify_fd;
}


/**
 * gets path from file descriptor
 * @param fd is the file descriptor as seen in /proc filesystem
 * @returns the name of the file pointed to by this file descriptor
 */
static gchar *get_file_path_from_fd(gint fd)
{
    gchar *path = NULL;
    gchar *proc = NULL;

    if (fd <= 0)
        {
            print_error(__FILE__, __LINE__, _("Invalid file descriptor: %d\n"), fd);
            return NULL;
        }

    proc = g_strdup_printf("/proc/self/fd/%d", fd);

    path = (gchar *) g_malloc0((PATH_MAX) * sizeof(gchar));

    if (readlink(proc, path, PATH_MAX - 1) < 0)
        {
            print_error(__FILE__, __LINE__, _("'readlink' error: %s\n"), strerror(errno));
            free_variable(proc);
            free_variable(path);
            return NULL;
        }

    free_variable(proc);

    return path;
}


static char *get_program_name_from_pid(int pid)
{
    int fd = 0;
    ssize_t len = 0;
    char *aux = NULL;
    gchar *cmd = NULL;
    gchar *buffer = NULL;

    /* Try to get program name by PID */
    cmd = g_strdup_printf("/proc/%d/cmdline", pid);

    if ((fd = open(cmd, O_RDONLY)) < 0)
        {
            return NULL;
        }

    buffer = (gchar *) g_malloc0(PATH_MAX);

    /* Read file contents into buffer */
    if ((len = read(fd, buffer, PATH_MAX - 1)) <= 0)
        {
            close (fd);
            free_variable(buffer);
            return NULL;
        }
    else
        {
            close (fd);

            /* buffer[len] = '\0'; */
            aux = strstr(buffer, "^@");

            if (aux)
                {
                    *aux = '\0';
                }

            return buffer;
        }
}


/**
 * Prepares everything in order to call save_one_file function that does
 * everything to save one file !
 * @param main_struct : main structure of the program
 * @param path is the entire path and name of the considered file.
 */
static void prepare_before_saving(main_struct_t *main_struct, gchar *path)
{
    gchar *directory = NULL;
    GFileInfo *fileinfo = NULL;
    GFile *file = NULL;
    GError *error = NULL;

    if (main_struct != NULL && path != NULL)
        {
            directory = g_path_get_dirname(path);
            file = g_file_new_for_path(path);
            fileinfo = g_file_query_info(file, "*", G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, NULL, &error);

            if (error == NULL && fileinfo != NULL)
                {
                    save_one_file(main_struct, directory, fileinfo);

                    fileinfo = free_object(fileinfo);
                    file = free_object(file);
                    free_variable(directory);
                }
            else
                {
                    print_error(__FILE__, __LINE__, _("Unable to get meta datas for file %s: %s\n"), path, error->message);
                    error = free_error(error);
                }
        }
}


/**
 * An example of processing events
 * @param dir_list MUST be a list of gchar * g_utf8_casefold()
 *        transformed.
 */
static void event_process(main_struct_t *main_struct, struct fanotify_event_metadata *event, GSList *dir_list)
{
    gchar *path = NULL;
    gchar *progname = NULL;
    GSList *head = dir_list;
    gboolean found = FALSE;
    gchar *pathutf8 = NULL;
    gchar *dirutf8 = NULL;

    path = get_file_path_from_fd(event->fd);

    if (path != NULL)
        {
            /* Does the event concern a monitored directory ? */
            pathutf8 = g_utf8_casefold(path, -1);

            while (head != NULL && found == FALSE)
                {
                    dirutf8 = head->data;

                    if (g_str_has_prefix(pathutf8, dirutf8) == TRUE)
                        {
                            found = TRUE;
                        }
                    else
                        {
                            head = g_slist_next(head);
                        }
                }

            pathutf8 = free_variable(pathutf8);

            if (found == TRUE)
                {
                    progname = get_program_name_from_pid(event->pid);

                    if (g_strcmp0(PROGRAM_NAME, progname) != 0)
                        {
                            /* Don't try to save files that comes from our activity */
                            print_debug(_("Received event file/directory: %s\n"), path);
                            print_debug(_(" matching directory is       : %s\n"), head->data);
                            print_debug(_(" pid=%d (%s): "), event->pid, progname);

                            if (event->mask & FAN_CLOSE_WRITE)
                                {
                                    print_debug(_("\tFAN_CLOSE_WRITE\n"));
                                }

                            /* Saving the file effectively */
                            prepare_before_saving(main_struct, path);

                            fflush (stdout);
                        }
                    free_variable(progname);
                }

            close(event->fd);
            free_variable(path);
        }
}


/**
 * Stops fanotify notifications
 * @param opt is the options of the program
 * @param fanotify_fd is the file descriptor of the file which is
 *        concerned by the event.
 */
void stop_fanotify(options_t *opt, int fanotify_fd)
{
    GSList *head = NULL;
    /* Setup fanotify notifications (FAN) mask. All these defined in linux/fanotify.h.    */
    static uint64_t event_mask =
      (FAN_CLOSE_WRITE   |  /* Writtable file closed                                      */
       FAN_ONDIR         |  /* We want to be reported of events in the directory          */
       FAN_EVENT_ON_CHILD); /* We want to be reported of events in files of the directory */

    if (opt != NULL)
        {
            head = opt->dirname_list;

            while (head != NULL)
                {
                    fanotify_mark(fanotify_fd, FAN_MARK_REMOVE, event_mask, AT_FDCWD, head->data);
                    head = g_slist_next(head);
                }

        }

    close(fanotify_fd);
}


/**
 * Transforms a list of directory into a list of directory ready for
 * comparison
 * @param dir_list is the list of directories to be transformed. This
 *        list is leaved untouched.
 * @returns a newly allocated list that may be freed when no longer
 *          needed.
 */
static GSList *transform_to_utf8_casefold(GSList *dir_list)
{
    GSList *head = NULL;
    GSList *utf8 = NULL;
    gchar *charutf8 = NULL;

    head = dir_list;

    while (head != NULL)
        {
            charutf8 = g_utf8_casefold(head->data, -1);

            /* Order of utf8 list is not very important */
            utf8 = g_slist_prepend(utf8, charutf8);

            head = g_slist_next(head);
        }

    return utf8;
}


/**
 * fanotify main loop
 * @todo simplify code (CCN is 12 already !)
 */
void fanotify_loop(main_struct_t *main_struct)
{
    struct pollfd fds[FD_POLL_MAX];
    struct signalfd_siginfo fdsi;
    char buffer[FANOTIFY_BUFFER_SIZE];
    ssize_t length = 0;
    struct fanotify_event_metadata *fe_mdata = NULL;
    GSList *dir_list_utf8 = NULL;


    gint signal_fd = 0;
    gint fanotify_fd = 0;

    if (main_struct != NULL)
        {
            signal_fd = main_struct->signal_fd;
            fanotify_fd = main_struct->fanotify_fd;


            /* Setup polling */
            fds[FD_POLL_SIGNAL].fd = signal_fd;
            fds[FD_POLL_SIGNAL].events = POLLIN;
            fds[FD_POLL_FANOTIFY].fd = fanotify_fd;
            fds[FD_POLL_FANOTIFY].events = POLLIN;


            dir_list_utf8 = transform_to_utf8_casefold(main_struct->opt->dirname_list);

            while (1)
                {
                    /* Block until there is something to be read */
                    if (poll(fds, FD_POLL_MAX, -1) < 0)
                        {
                            print_error(__FILE__, __LINE__, _("Couldn't poll(): '%s'\n"), strerror(errno));
                        }

                    /* Signal received ? */
                    if (fds[FD_POLL_SIGNAL].revents & POLLIN)
                        {
                            if (read(fds[FD_POLL_SIGNAL].fd, &fdsi, sizeof(fdsi)) != sizeof(fdsi))
                                {
                                  print_error(__FILE__, __LINE__, _("Couldn't read signal, wrong size read\n"));
                                }

                            /* Break loop if we got SIGINT or SIGTERM */
                            if (fdsi.ssi_signo == SIGINT || fdsi.ssi_signo == SIGTERM)
                                {
                                    stop_fanotify(main_struct->opt, main_struct->fanotify_fd);
                                    free_list(dir_list_utf8);
                                    break;
                                }

                            print_error(__FILE__, __LINE__, _("Received unexpected signal\n"));
                        }


                    /* fanotify event received ? */
                    if (fds[FD_POLL_FANOTIFY].revents & POLLIN)
                        {
                            /* Read from the FD. It will read all events available up to
                             * the given buffer size. */
                            if ((length = read (fds[FD_POLL_FANOTIFY].fd, buffer, FANOTIFY_BUFFER_SIZE)) > 0)
                                {
                                    fe_mdata = (struct fanotify_event_metadata *) buffer;

                                    while (FAN_EVENT_OK(fe_mdata, length))
                                        {
                                            event_process(main_struct, fe_mdata, dir_list_utf8);

                                            if (fe_mdata->fd > 0)
                                                {
                                                    close(fe_mdata->fd);
                                                }

                                            fe_mdata = FAN_EVENT_NEXT(fe_mdata, length);
                                        }
                                }
                        }
                }

        }

}



/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    m_fanotify.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file m_fanotify.h
 *
 * In this file we have all definition for fanotify's monitor interface.
 */
#ifndef _M_FANOTIFY_H_
#define _M_FANOTIFY_H_

#define FANOTIFY_BUFFER_SIZE 49152    /* for 24 bytes events this is 2046 events */

/* Enumerate list of FDs to poll */
enum {
  FD_POLL_SIGNAL = 0,
  FD_POLL_FANOTIFY,
  FD_POLL_MAX
};


/**
 * Stops signal handling
 */
extern void  stop_signals(int signal_fd);


/**
 * Starts signal handling
 */
extern gint start_signals(void);


/**
 * Inits and starts fanotify notifications
 * @param opt : a filled options_t * structure that contains all options
 *        by default, read into the file or selected in the command line.
 */
extern gint start_fanotify(options_t *opt);


/**
 * Stops fanotify notifications
 */
extern void stop_fanotify(options_t *opt, int fanotify_fd);


/**
 * fanotify main loop
 * @todo simplify code (CCN is 12 already !)
 */
extern void fanotify_loop(main_struct_t *main_struct);

#endif /* #IFNDEF _M_FANOTIFY_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    monitor.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file monitor.c
 *
 * This file is the main file for the monitor program. This monitor
 * program has to monitor file changes onto filesystems. It should notice
 * when a file is created, deleted or changed
 */

#include "monitor.h"

static main_struct_t *init_main_structure(options_t *opt);
static GSList *calculate_hash_data_list_for_file(GFile *a_file, gint64 blocksize);
static meta_data_t *get_meta_data_from_fileinfo(gchar *directory, GFileInfo *fileinfo, gint64 blocksize, db_t *database);
static gchar *send_meta_data_to_serveur(main_struct_t *main_struct, meta_data_t *meta);
static hash_data_t *find_hash_in_list(GSList *hash_data_list, guint8 *hash);
static gint send_datas_to_serveur(main_struct_t *main_struct, meta_data_t *meta, gchar *answer);
static void iterate_over_enum(main_struct_t *main_struct, gchar *directory, GFileEnumerator *file_enum);
static void carve_one_directory(gpointer data, gpointer user_data);
static void carve_all_directories(main_struct_t *main_struct);


/**
 * Inits the main structure.
 * @note With sqlite version > 3.7.7 we should use URI filename.
 * @param opt : a filled options_t * structure that contains all options
 *        by default, read into the file or selected in the command line.
 * @returns a main_struct_t * pointer to the main structure
 */
static main_struct_t *init_main_structure(options_t *opt)
{
    main_struct_t *main_struct = NULL;
    gchar *db_uri = NULL;
    gchar *conn = NULL;

    if (opt != NULL)
        {

            print_debug(_("Please wait while initializing main structure...\n"));

            main_struct = (main_struct_t *) g_malloc0(sizeof(main_struct_t));

            create_directory(opt->dircache);
            db_uri = g_build_filename(opt->dircache, opt->dbname , NULL);
            main_struct->database = open_database(db_uri);
            db_uri = free_variable(db_uri);

            main_struct->opt = opt;
            main_struct->hostname = g_get_host_name();

            if (opt != NULL && opt->ip != NULL)
                {
                    conn = make_connexion_string(opt->ip, opt->port);
                    main_struct->comm = init_comm_struct(conn);
                }
            else
                {
                    /* This should never happen because we have default values */
                    main_struct->comm = NULL;
                }

            main_struct->signal_fd = start_signals();
            main_struct->fanotify_fd = start_fanotify(opt);

            print_debug(_("Main structure initialized !\n"));

        }

    return main_struct;
}


/**
 * Calculates hashs for each block of blocksize bytes long on the file
 * and returns a list of all hashs in correct order stored in a binary
 * form to save space.
 * @note This technique has some limits in term of memory footprint
 *       because one file is entirely in memory at a time. Saving huge
 *       files may not be possible with this, depending on the size of
 *       the file and the size of the memory.
 * @todo Imagine a new way to checksum huge files because of limitations.
 *       May be with the local sqlite database ?
 * @param a_file is the file from which we want the hashs.
 * @param blocksize is the blocksize to be used to calculate hashs upon.
 * @returns a GSList * list of hashs stored in a binary form.
 */
static GSList *calculate_hash_data_list_for_file(GFile *a_file, gint64 blocksize)
{
    GFileInputStream *stream = NULL;
    GError *error = NULL;
    GSList *hash_data_list = NULL;
    hash_data_t *hash_data = NULL;
    gssize read = 0;
    guchar *buffer = NULL;
    GChecksum *checksum = NULL;
    guint8 *a_hash = NULL;
    gsize digest_len = HASH_LEN;

    if (a_file != NULL)
        {
            stream = g_file_read(a_file, NULL, &error);

            if (stream != NULL && error == NULL)
                {

                    checksum = g_checksum_new(G_CHECKSUM_SHA256);
                    buffer = (guchar *) g_malloc0(blocksize);
                    a_hash = (guint8 *) g_malloc0(digest_len);

                    read = g_input_stream_read((GInputStream *) stream, buffer, blocksize, NULL, &error);

                    while (read != 0 && error == NULL)
                        {
                            g_checksum_update(checksum, buffer, read);
                            g_checksum_get_digest(checksum, a_hash, &digest_len);

                            /* Need to save data and read in hash_data_t structure */
                            hash_data = new_hash_data_t(buffer, read, a_hash);

                            hash_data_list = g_slist_prepend(hash_data_list, hash_data);
                            g_checksum_reset(checksum);
                            digest_len = HASH_LEN;

                            buffer = (guchar *) g_malloc0(blocksize);
                            a_hash = (guint8 *) g_malloc0(digest_len);
                            read = g_input_stream_read((GInputStream *) stream, buffer, blocksize, NULL, &error);
                        }

                    if (error != NULL)
                        {
                            print_error(__FILE__, __LINE__, _("Error while reading file: %s\n"), error->message);
                            error = free_error(error);
                            g_slist_free_full(hash_data_list, free_hdt_struct);
                            hash_data_list =  NULL;
                        }
                    else
                        {
                            /* get the list in correct order (because we prepended the hashs to get speed when inserting hashs in the list) */
                            hash_data_list = g_slist_reverse(hash_data_list);
                        }

                    g_checksum_free(checksum);
                    g_input_stream_close((GInputStream *) stream, NULL, NULL);
                    free_object(stream);
                }
            else
                {
                    print_error(__FILE__, __LINE__, _("Unable to open file for reading: %s\n"), error->message);
                    error = free_error(error);
                }
        }

    return hash_data_list;
}


/**
 * Gets all meta data for a file and returns a filled meta_data_t *
 * structure.
 * @param directory is the directory we are iterating over it is used
 *        here to build the filename name.
 * @param fileinfo is a glib structure that contains all meta datas and
 *        more for a file.
 * @param blocksize is the blocksize to be used to calculate hashs upon.
 * @param database is the db_t * structure to access thhe local database
 *        cache in order to know if we already know this file (and thus
 *        not process it).
 * @returns a newly allocated and filled meta_data_t * structure.
 */
static meta_data_t *get_meta_data_from_fileinfo(gchar *directory, GFileInfo *fileinfo, gint64 blocksize, db_t *database)
{
    meta_data_t *meta = NULL;
    GFile *a_file = NULL;

    if (directory != NULL && fileinfo != NULL && database != NULL)
        {
            /* filling meta data for the file represented by fileinfo */
            meta = new_meta_data_t();

            meta->file_type = g_file_info_get_file_type(fileinfo);
            meta->name = g_build_path(G_DIR_SEPARATOR_S, directory, g_file_info_get_name(fileinfo), NULL);
            meta->inode = g_file_info_get_attribute_uint64(fileinfo, G_FILE_ATTRIBUTE_UNIX_INODE);
            meta->owner = g_file_info_get_attribute_as_string(fileinfo, G_FILE_ATTRIBUTE_OWNER_USER);
            meta->group = g_file_info_get_attribute_as_string(fileinfo, G_FILE_ATTRIBUTE_OWNER_GROUP);
            meta->uid = g_file_info_get_attribute_uint32(fileinfo, G_FILE_ATTRIBUTE_UNIX_UID);
            meta->gid = g_file_info_get_attribute_uint32(fileinfo, G_FILE_ATTRIBUTE_UNIX_GID);
            meta->atime = g_file_info_get_attribute_uint64(fileinfo, G_FILE_ATTRIBUTE_TIME_ACCESS);
            meta->ctime = g_file_info_get_attribute_uint64(fileinfo, G_FILE_ATTRIBUTE_TIME_CHANGED);
            meta->mtime = g_file_info_get_attribute_uint64(fileinfo, G_FILE_ATTRIBUTE_TIME_MODIFIED);
            meta->mode = g_file_info_get_attribute_uint32(fileinfo, G_FILE_ATTRIBUTE_UNIX_MODE);
            meta->size = g_file_info_get_attribute_uint64(fileinfo, G_FILE_ATTRIBUTE_STANDARD_SIZE);

             /* Do the right things with specific cases */
            if (meta->file_type == G_FILE_TYPE_SYMBOLIC_LINK)
                {
                    meta->link = (gchar *) g_file_info_get_attribute_byte_string(fileinfo, G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET);
                }
            else
                {
                    meta->link = g_strdup("");
                }


            /* We need to determine if the file has already been saved by looking into the local database */
            meta->in_cache = is_file_in_cache(database, meta);


            if (meta->in_cache == FALSE && meta->file_type == G_FILE_TYPE_REGULAR)
                {
                    /* Calculates hashs and takes care of data */
                    a_file = g_file_new_for_path(meta->name);
                    meta->hash_data_list = calculate_hash_data_list_for_file(a_file, blocksize);
                    a_file = free_object(a_file);
                }
        }

    return meta;
}


/**
 * Sends meta datas to the serveur and returns it's answer or NULL in
 * case of an error.
 * @param main_struct : main structure of the program (contains pointers
 *        to the communication socket.
 * @param meta : the meta_data_t * structure to be saved.
 */
static gchar *send_meta_data_to_serveur(main_struct_t *main_struct, meta_data_t *meta)
{
    gchar *json_str = NULL;
    gchar *answer = NULL;
    gint success = CURLE_FAILED_INIT;

    if (main_struct != NULL && meta != NULL && main_struct->hostname != NULL)
        {
            json_str = convert_meta_data_to_json_string(meta, main_struct->hostname);

            /* Sends meta data here */
            print_debug(_("Sending meta datas: %s\n"), json_str);
            main_struct->comm->buffer = json_str;
            success = post_url(main_struct->comm, "/Meta.json");

            free_variable(json_str);

            if (success == CURLE_OK)
                {
                    answer = g_strdup(main_struct->comm->buffer);
                    main_struct->comm->buffer = free_variable(main_struct->comm->buffer);
                }
            else
                {
                    /* Need to manage HTTP errors */
                }
        }

    return answer;
}


/**
 * Finds a hash in the hash data list and returns the hash_data_t that
 * corresponds to it. In normal operations it should always find
 * something.
 * @param hash_data_list is the list to look into for the hash 'hash'
 * @param hash is the hash to look for.
 * @returns the hash_data_t  structure that corresponds to the hash 'hash'.
 */
static hash_data_t *find_hash_in_list(GSList *hash_data_list, guint8 *hash)
{
    GSList *iter = hash_data_list;
    hash_data_t *found = NULL;
    gboolean ok = FALSE;

    while (iter != NULL && ok == FALSE)
        {
            found = iter->data;

            if (compare_two_hashs(hash, found->hash) == 0)
                {
                    ok = TRUE;
                }
            else
                {
                   iter = g_slist_next(iter);
                }
        }

    if (ok == TRUE)
        {
            return found;
        }
    else
        {
            return NULL;
        }
}


/**
 * Sends datas as requested by the server 'serveur'.
 * @param main_struct : main structure of the program.
 * @param meta : the meta_data_t * structure to be saved and that
 *        contains the datas.
 * @param answer is the request sent back by serveur when we had send
 *        meta datas.
 * @note using directly main_struct->comm->buffer -> not threadable as is.
 */
static gint send_datas_to_serveur(main_struct_t *main_struct, meta_data_t *meta, gchar *answer)
{
    json_t *root = NULL;
    GSList *hash_list = NULL;         /** hash_list is local to this function */
    GSList *head = NULL;
    gint success = CURLE_FAILED_INIT;
    hash_data_t *found = NULL;
    hash_data_t *hash_data = NULL;
    gint all_ok = CURLE_OK;

    if (answer != NULL && meta != NULL)
        {
            root = load_json(answer);

            if (root != NULL)
                {

                    /* This hash_list is the needed hashs from serveur */
                    hash_list = extract_gslist_from_array(root, "hash_list");
                    json_decref(root);
                    head = hash_list;

                    while (hash_list != NULL && all_ok == CURLE_OK)
                        {
                            hash_data = hash_list->data;
                            /* hash_data_list contains all hashs and their associated datas */
                            found = find_hash_in_list(meta->hash_data_list, hash_data->hash);

                            /* main_struct->comm->buffer is the buffer sent to serveur */
                            main_struct->comm->buffer = convert_hash_data_t_to_json(found);
                            success = post_url(main_struct->comm, "/Data.json");

                            all_ok = success;

                            main_struct->comm->buffer = free_variable(main_struct->comm->buffer);
                            hash_list = g_slist_next(hash_list);
                        }

                    if (head != NULL)
                        {
                            g_slist_free_full(head, free_hdt_struct);
                        }
                }
            else
                {
                    print_error(__FILE__, __LINE__, _("Error while loading JSON answer from serveur\n"));
                }
        }

   return all_ok;
}


/**
 * This function gets meta datas and datas from a file and sends them
 * to the serveur in order to save the file located in the directory
 * 'directory' and represented by 'fileinfo' variable.
 * @param main_struct : main structure of the program
 * @param directory is the directory we are iterating over
 * @param fileinfo is a glib structure that contains all meta datas and
 *        more for a file.
 * @note This function is not threadable as is. One may have problems
 *       when writing to the database for instance.
 */
void save_one_file(main_struct_t *main_struct, gchar *directory, GFileInfo *fileinfo)
{
    meta_data_t *meta = NULL;
    gchar *answer = NULL;
    gint success = 0;
    a_clock_t *my_clock = NULL;
    gchar *message = NULL;

    if (main_struct != NULL && main_struct->opt != NULL && directory != NULL && fileinfo != NULL)
        {

            my_clock = new_clock_t();

            /* Get datas and meta_datas for a file. */
            meta = get_meta_data_from_fileinfo(directory, fileinfo, main_struct->opt->blocksize, main_struct->database);

            if (meta->in_cache == FALSE)
                {
                    /* Send datas and meta datas only if the file isn't already in our local database */
                    answer = send_meta_data_to_serveur(main_struct, meta);
                    success = send_datas_to_serveur(main_struct, meta, answer);
                    free_variable(answer);

                    /* Save them to the db cache */
                    db_save_meta_data(main_struct->database, meta, TRUE);

                    /* Need to save datas only if an error occured when transmitting. 'success' may tell this */
                }

            message = g_strdup_printf(_("processing file %s"), meta->name);
            end_clock(my_clock, message);
            free_variable(message);

            if (meta->file_type == G_FILE_TYPE_DIRECTORY)
                {
                    /* This is a recursive call */
                    carve_one_directory(meta->name, main_struct);
                }

            meta = free_meta_data_t(meta);
        }


}


/**
 * Iterates over an enumerator obtained from a directory.
 * @param main_struct : main structure of the program
 * @param directory is the directory we are iterating over
 * @param file_enum is the enumerator obtained when opening a directory
 *        to carve it.
 */
static void iterate_over_enum(main_struct_t *main_struct, gchar *directory, GFileEnumerator *file_enum)
{
    GError *error = NULL;
    GFileInfo *fileinfo = NULL;

    if (main_struct != NULL && file_enum != NULL)
        {
            fileinfo = g_file_enumerator_next_file(file_enum, NULL, &error);

            while (error == NULL && fileinfo != NULL)
                {
                    save_one_file(main_struct, directory, fileinfo);

                    fileinfo = free_object(fileinfo);

                    fileinfo = g_file_enumerator_next_file(file_enum, NULL, &error);
                }
        }
}


/**
 * Call back for the g_slist_foreach function that carves one directory
 * and sub directories in a recursive way.
 * @param data is an element of opt->list ie: a gchar * that represents
 *        a directory name
 * @param user_data is the main_struct_t * pointer to the main structure.
 */
static void carve_one_directory(gpointer data, gpointer user_data)
{
    gchar *directory = (gchar *) data;
    main_struct_t *main_struct = (main_struct_t *) user_data;

    GFile *a_dir = NULL;
    GFileEnumerator *file_enum = NULL;
    GError *error = NULL;

    if (directory != NULL && main_struct != NULL)
        {
            a_dir = g_file_new_for_path(directory);
            file_enum = g_file_enumerate_children(a_dir, "*", G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, NULL, &error);

            if (error == NULL && file_enum != NULL)
                {
                    iterate_over_enum(main_struct, directory, file_enum);
                    g_file_enumerator_close(file_enum, NULL, NULL);
                    file_enum = free_object(file_enum);
                }
            else
                {
                    print_error(__FILE__, __LINE__, _("Unable to enumerate directory %s: %s\n"), directory, error->message);
                    error = free_error(error);
                }

            a_dir = free_object(a_dir);
        }
}


/**
 * Does carve all directories from the list in the option list
 * @param main_struct : main structure of the program that contains also
 *        the options structure that should have a list of directories
 *        to save.
 */
static void carve_all_directories(main_struct_t *main_struct)
{
    if (main_struct != NULL && main_struct->opt != NULL)
        {
            g_slist_foreach(main_struct->opt->dirname_list, carve_one_directory, main_struct);
        }
}


/**
 * Main function
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 * @returns always 0
 */
int main(int argc, char **argv)
{
    options_t *opt = NULL;  /** Structure to manage options from the command line can be freed when no longer needed */
    main_struct_t *main_struct = NULL;

    #if !GLIB_CHECK_VERSION(2, 36, 0)
        g_type_init();  /** g_type_init() is deprecated since glib 2.36 */
    #endif

    init_international_languages();
    curl_global_init(CURL_GLOBAL_ALL);

    opt = do_what_is_needed_from_command_line_options(argc, argv);

    if (opt != NULL)
        {
            main_struct = init_main_structure(opt);

            carve_all_directories(main_struct);

            /** Launching an infinite loop to get modifications done on
             * the filesystem (on directories we watch).
             * @note fanotify's kernel interface does not provide the events
             * needed to know if a file has been deleted or it's attributes
             * changed. Enabling this feature even if we know that files
             * will never get deleted in our database.
             */
            fanotify_loop(main_struct);

            free_options_t_structure(main_struct->opt);
        }

    return 0;
}
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    options.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file monitor/options.c
 *
 *  This file contains all the functions to manage command line options.
 * @todo review file configuration sections to make it more consistant
 *       with actual program.
 */

#include "monitor.h"

static void print_selected_options(options_t *opt);
static void read_from_group_monitor(options_t *opt, GKeyFile *keyfile, gchar *filename);
static void read_from_group_ciseaux(options_t *opt, GKeyFile *keyfile, gchar *filename);
static void read_from_group_antememoire(options_t *opt, GKeyFile *keyfile, gchar *filename);
static void read_from_group_serveur(options_t *opt, GKeyFile *keyfile, gchar *filename);
static void read_from_configuration_file(options_t *opt, gchar *filename);


/**
 * Prints options as selected when invoking the program with -v option
 * @param opt the options_t * structure that contains all selected options
 *        from the command line and that will be used by the program.
 */
static void print_selected_options(options_t *opt)
{
    GSList *head = NULL;

    if (opt != NULL)
        {
            fprintf(stdout, _("\n%s options are:\n"), PROGRAM_NAME);

            if (opt->dirname_list != NULL)
                {
                    fprintf(stdout, _("Directory list:\n"));
                    head = opt->dirname_list;
                    while (head != NULL)
                        {
                            fprintf(stdout, "\t%s\n", (char *) head->data);
                            head = g_slist_next(head);
                        }
                }

            fprintf(stdout, _("Blocksize: %" G_GINT64_FORMAT "\n"), opt->blocksize);

            print_string_option(_("Configuration file: %s\n"), opt->configfile);
            print_string_option(_("Cache directory: %s\n"), opt->dircache);
            print_string_option(_("Cache database name: %s\n"), opt->dbname);
            print_string_option(_("serveur's IP address: %s\n"), opt->ip);
            fprintf(stdout, _("serveur's port number: %d\n"), opt->port);
        }
}


/**
 * Reads keys in keyfile if group GN_MONITOR is in that keyfile and fills
 * options_t *opt structure accordingly.
 * @param[in,out] opt : options_t * structure to store options read from the
 *                configuration file "filename".
 * @param keyfile is the GKeyFile structure that is used by glib to read
 *        groups and keys from.
 * @param filename : the filename of the configuration file to read from
 */
static void read_from_group_monitor(options_t *opt, GKeyFile *keyfile, gchar *filename)
{
    gboolean debug = FALSE;

    if (keyfile != NULL && filename != NULL && g_key_file_has_group(keyfile, GN_MONITOR) == TRUE)
        {
            /* Reading the directory list */
            opt->dirname_list = read_list_from_file(keyfile, filename, GN_MONITOR, KN_DIR_LIST, _("Could not load directory list from file"));

            debug = read_boolean_from_file(keyfile, filename, GN_ALL, KN_DEBUG_MODE, _("Could not load debug mode configuration from file."));

            set_debug_mode(debug);
        }
}


/**
 * Reads keys in keyfile if group GN_CISEAUX is in that keyfile and fills
 * options_t *opt structure accordingly.
 * @param[in,out] opt : options_t * structure to store options read from the
 *                configuration file "filename".
 * @param keyfile is the GKeyFile structure that is used by glib to read
 *        groups and keys from.
 * @param filename : the filename of the configuration file to read from
 */
static void read_from_group_ciseaux(options_t *opt, GKeyFile *keyfile, gchar *filename)
{
    if (keyfile != NULL && filename != NULL && g_key_file_has_group(keyfile, GN_CISEAUX) == TRUE)
        {
            /* Reading the blocksize if any */
            opt->blocksize = read_int64_from_file(keyfile, filename, GN_CISEAUX, KN_BLOCK_SIZE, _("Could not load blocksize from file"));
        }
}


/**
 * Reads keys in keyfile if group GN_ANTEMEMOIRE is in that keyfile and fills
 * options_t *opt structure accordingly.
 * @param[in,out] opt : options_t * structure to store options read from the
 *                configuration file "filename".
 * @param keyfile is the GKeyFile structure that is used by glib to read
 *        groups and keys from.
 * @param filename : the filename of the configuration file to read from
 */
static void read_from_group_antememoire(options_t *opt, GKeyFile *keyfile, gchar *filename)
{
    if (keyfile != NULL && filename != NULL && g_key_file_has_group(keyfile, GN_ANTEMEMOIRE) == TRUE)
        {
            /* Reading the cache directory if any */
            opt->dircache = read_string_from_file(keyfile, filename, GN_ANTEMEMOIRE, KN_CACHE_DIR, _("Could not load directory name"));

            /* Reading filename of the database if any */
            opt->dbname = read_string_from_file(keyfile, filename, GN_ANTEMEMOIRE, KN_DB_NAME, _("Could not load cache database name"));
        }
}


/**
 * Reads keys in keyfile if groupname is in that keyfile and fills
 * options_t *opt structure accordingly.
 * @param[in,out] opt : options_t * structure to store options read from the
 *                configuration file "filename".
 * @param keyfile is the GKeyFile structure that is used by glib to read
 *        groups and keys from.
 * @param filename : the filename of the configuration file to read from
 */
static void read_from_group_serveur(options_t *opt, GKeyFile *keyfile, gchar *filename)
{
    gint port = 0;

    if (opt != NULL && keyfile != NULL && filename != NULL && g_key_file_has_group(keyfile, GN_SERVEUR) == TRUE)
        {
            /* Reading the port number if any */
            port = read_int_from_file(keyfile, filename, GN_SERVEUR, KN_SERVEUR_PORT, _("Could not load serveur port number from file."));

            if (port > 1024 && port < 65535)
                {
                    opt->port = port;
                }

            /* Reading IP address of serveur's host if any */
            opt->ip = read_string_from_file(keyfile, filename, GN_SERVEUR, KN_SERVEUR_IP, _("Could not load cache database name"));
        }
}


/**
 * Reads from the configuration file "filename" and fills the options_t *
 * opt structure.
 * @param[in,out] opt : options_t * structure to store options read from
 *                the configuration file "filename"
 * @param filename : the filename of the configuration file to read from
 */
static void read_from_configuration_file(options_t *opt, gchar *filename)
{
    GKeyFile *keyfile = NULL;      /** Configuration file parser                          */
    GError *error = NULL;          /** Glib error handling                                */

    if (filename != NULL)
        {

            if (opt->configfile != NULL)
                {
                    free_variable(opt->configfile);
                }
            opt->configfile = g_strdup(filename);

            print_debug(_("Reading configuration from file %s\n"), filename);

            keyfile = g_key_file_new();

            if (g_key_file_load_from_file(keyfile, filename, G_KEY_FILE_KEEP_COMMENTS, &error))
                {
                    read_from_group_monitor(opt, keyfile, filename);
                    read_from_group_ciseaux(opt, keyfile, filename);
                    read_from_group_antememoire(opt, keyfile, filename);
                    read_from_group_serveur(opt, keyfile, filename);
                }
            else if (error != NULL)
                {
                    print_error(__FILE__, __LINE__, _("Failed to open %s configuration file : %s\n"), filename, error->message);
                    error = free_error(error);
                }

            g_key_file_free(keyfile);
        }
}


/**
 * This function parses command line options. It sets the options in this
 * order. It means that the value used for an option is the one set in the
 * lastest step.
 * 0) default values are set into the options_t * structure
 * 1) reads the default configuration file if any.
 * 2) reads the configuration file mentionned on the command line.
 * 3) sets the command line options (except for the list of directories,
 *    all other values are replaced by thoses in the command line)
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 * @returns options_t structure malloc'ed and filled upon choosen command
 *          line's option
 */
options_t *manage_command_line_options(int argc, char **argv)
{
    gboolean version = FALSE;      /** True if -v was selected on the command line           */
    gint debug = -4;               /** 0 == FALSE and other values == TRUE                   */
    gchar **dirname_array = NULL;  /** array of dirnames left on the command line            */
    gchar *configfile = NULL;      /** filename for the configuration file if any            */
    gint64 blocksize = 0;          /** computed block size in bytes                          */
    gboolean noprint = FALSE;      /** True if we do not want to print will checksuming      */
    gchar *dircache = NULL;        /** Directory used to store cache files                   */
    gchar *dbname = NULL;          /** Database filename where data and meta data are cached */
    gchar *ip =  NULL;             /** IP address where is located serveur's program         */
    gint port = 0;                 /** Port number on which to send things to the server     */

    GOptionEntry entries[] =
    {
        { "version", 'v', 0, G_OPTION_ARG_NONE, &version, N_("Prints program version"), NULL },
        { "debug", 'd', 0,  G_OPTION_ARG_INT, &debug, N_("Activates (1) or desactivates (0) debug mode."), N_("BOOLEAN")},
        { "configuration", 'c', 0, G_OPTION_ARG_STRING, &configfile, N_("Specify an alternative configuration file."), N_("FILENAME")},
        { "blocksize", 'b', 0, G_OPTION_ARG_INT64 , &blocksize, N_("Block SIZE used to compute hashs."), N_("SIZE")},
        { "noprint", 'n', 0, G_OPTION_ARG_NONE, &noprint, N_("Quiets the program while calculating checksum."), NULL},
        { "dircache", 'r', 0, G_OPTION_ARG_STRING, &dircache, N_("Directory DIRNAME where to cache files."), N_("DIRNAME")},
        { "dbname", 'f', 0, G_OPTION_ARG_STRING, &dbname, N_("Database FILENAME."), N_("FILENAME")},
        { "ip", 'i', 0, G_OPTION_ARG_STRING, &ip, N_("IP address where serveur program is."), "IP"},
        { "port", 'p', 0, G_OPTION_ARG_INT, &port, N_("Port NUMBER on which to listen."), N_("NUMBER")},
        { G_OPTION_REMAINING, 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &dirname_array, "", NULL},
        { NULL }
    };

    GError *error = NULL;
    GOptionContext *context;
    options_t *opt = NULL;    /** Structure to manage program's options            */
    gchar *bugreport = NULL;  /** Bug Report message                               */
    gchar *summary = NULL;    /** Abstract for the program                         */
    gchar *defaultconfigfilename = NULL;

    bugreport = g_strconcat(_("Please report bugs to: "), PACKAGE_BUGREPORT, NULL);
    summary = g_strdup(_("This program is monitoring file changes in the filesystem and is hashing\nfiles with SHA256 algorithms from Glib."));
    context = g_option_context_new("");

    set_debug_mode(ENABLE_DEBUG);

    set_option_context_options(context, entries, TRUE, bugreport, summary);

    if (!g_option_context_parse(context, &argc, &argv, &error))
        {
            g_print(_("Option parsing failed: %s\n"), error->message);
            exit(EXIT_FAILURE);
        }

    /* 0) Setting default values */

    opt = (options_t *) g_malloc0(sizeof(options_t));

    opt->dirname_list = NULL;
    opt->blocksize = CLIENT_BLOCK_SIZE;
    opt->noprint = FALSE;
    opt->configfile = NULL;
    opt->dircache = g_strdup("/var/tmp/sauvegarde");
    opt->dbname = g_strdup("filecache.db");
    opt->ip = g_strdup("localhost");
    opt->port = 5468;

    /* 1) Reading options from default configuration file */
    defaultconfigfilename = get_probable_etc_path(PROGRAM_NAME, "client.conf");
    read_from_configuration_file(opt,  defaultconfigfilename);
    defaultconfigfilename = free_variable(defaultconfigfilename);

    opt->version = version; /* only TRUE if -v or --version was invoked */

    set_debug_mode_upon_cmdl(debug);


    /* 2) Reading the configuration from the configuration file specified
     *    on the command line (if any).
     */
    if (configfile != NULL)
        {
            read_from_configuration_file(opt, configfile);
        }


    /* 3) retrieving other options from the command line. Directories are
     *    added to the existing directory list and then the array is freed
     *    as every string has been copied with g_strdup().
     */
    opt->dirname_list = convert_gchar_array_to_GSList(dirname_array, opt->dirname_list);
    g_strfreev(dirname_array);

    if (blocksize > 0)
        {
            opt->blocksize = blocksize;
        }

    if (noprint == TRUE)
        {
            opt->noprint = TRUE;
        }

    if (dircache != NULL)
        {
            free_variable(opt->dircache);
            opt->dircache = g_strdup(dircache);
        }

    if (dbname != NULL)
        {
            free_variable(opt->dbname);
            opt->dbname = g_strdup(dbname);
        }

    if (ip != NULL)
        {
            free_variable(opt->ip);
            opt->ip = g_strdup(ip);
        }

    if (port > 1024 && port < 65535)
        {
            opt->port = port;
        }

    g_option_context_free(context);
    free_variable(ip);
    free_variable(dbname);
    free_variable(dircache);
    free_variable(bugreport);
    free_variable(summary);

    return opt;
}


/**
 * Frees the options structure if necessary
 * @param opt : the malloc'ed options_t structure
 */
void free_options_t_structure(options_t *opt)
{
    if (opt != NULL)
        {
            free_list(opt->dirname_list);
            free_variable(opt->dircache);
            free_variable(opt->configfile);
            free_variable(opt->dbname);
            free_variable(opt->ip);
            free_variable(opt);
        }

}


/**
 * Decides what to do upon command lines options passed to the program
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 * @returns options_t structure malloc'ed and filled upon choosen command
 *          line's option (in manage_command_line_options function).
 */
options_t *do_what_is_needed_from_command_line_options(int argc, char **argv)
{
    options_t *opt = NULL;  /** Structure to manage options from the command line can be freed when no longer needed */

    opt = manage_command_line_options(argc, argv);

    if (opt != NULL)
        {
            if (opt->version == TRUE)
                {
                    print_program_version(PROGRAM_NAME, MONITOR_DATE, MONITOR_VERSION, MONITOR_AUTHORS, MONITOR_LICENSE);
                    print_libraries_versions(PROGRAM_NAME);
                    print_selected_options(opt);
                    exit(EXIT_SUCCESS);
                }
        }

    return opt;
}


/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    monitor.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2014 - 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file monitor.h
 *
 *  This file contains all the definitions for the monitor program.
 */
#ifndef _MONITOR_H_
#define _MONITOR_H_

/* Configuration from ./configure script */
#include "config.h"


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <glib.h>
#include <gio/gio.h>
#include <glib/gi18n-lib.h>
#include <errno.h>

#include <signal.h>
#include <string.h>
#include <poll.h>
#include <limits.h>
#include <sys/stat.h>
#include <sys/signalfd.h>
#include <fcntl.h>
#include <sys/fanotify.h>

#include <libsauvegarde.h>

#include "options.h"


/**
 * @def MONITOR_DATE
 * Defines monitor's creation date
 *
 * @def MONITOR_AUTHORS
 * Defines monitor's main authors
 *
 * @def MONITOR_LICENSE
 * Defines monitor's license (at least GPL v2)
 *
 * @def MONITOR_VERSION
 * Defines monitor's version (which may be different of Sauvegarde's whole
 * project and programs that composes it).

 * @def PROGRAM_NAME
 * Defines the main program name for this part (monitor + ciseaux +
 * antememoire).
 */
#define MONITOR_AUTHORS ("Olivier DELHOMME <olivier.delhomme@free.fr>")
#define MONITOR_DATE _("15 08 2015")
#define MONITOR_LICENSE _("GPL v3 or later")
#define MONITOR_VERSION _("0.0.2")
#define PROGRAM_NAME ("client")


/**
 * @def CLIENT_BLOCK_SIZE
 * default block size in bytes
 */
#define CLIENT_BLOCK_SIZE (16384)


/**
 * @struct main_struct_t
 * @brief Structure that contains everything needed by the program.
 */
typedef struct
{
    options_t *opt;           /**< Options of the program from the command line                                                */
    const gchar *hostname;    /**< Name of the current machine                                                                 */
    db_t *database;           /**< Database structure that stores everything that is related to the database                   */
    comm_t *comm;             /**< This is used to communicate with the 'serveur' program (which is the server)                */
    gint signal_fd;           /**< signal handler   */
    gint fanotify_fd;         /**< fanotify handler */
} main_struct_t;


/**
 * This function gets meta datas and datas from a file and sends them
 * to the serveur in order to save the file located in the directory
 * 'directory' and represented by 'fileinfo' variable.
 * @param main_struct : main structure of the program
 * @param directory is the directory we are iterating over
 * @param fileinfo is a glib structure that contains all meta datas and
 *        more for a file.
 */
extern void save_one_file(main_struct_t *main_struct, gchar *directory, GFileInfo *fileinfo);


#include "m_fanotify.h"

#endif /* #IFNDEF _MONITOR_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    options.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file restaure/options.h
 *
 * This file contains all the definitions for the options of the command
 * line for 'restaure' program.
 *
 */
#ifndef _RESTAURE_OPTIONS_H_
#define _RESTAURE_OPTIONS_H_


/**
 * @struct options_t
 * @brief Selected options for 'serveur' program
 *
 * Structure Options gives a way to store program options passed from the
 * command line or read from a configuration file for 'serveur' program.
 */
typedef struct
{
    gboolean version;   /**< TRUE if we have to display program's version                                           */
    gchar *list;        /**< Should contain a filename to be searched into saved files filename's list              */
    gchar *restore;     /**< Must contain a filename or a directory name to be restored (latest version by default  */
    gchar *date;        /**< Should contain a date in the correct format to filter only files at that specific date */
    gchar *configfile;  /**< Filename for the configuration file specified on the command line                      */
    gchar *ip;          /**< A string representing the IP address where serveur is located (may be a hotsname)      */
    gint port;          /**< Port number on which to send things to serveur's server (on which it must listen)      */
} options_t;


/**
 * Decides what to do upon command lines options passed to the program
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 * @returns options_t structure malloc'ed and filled upon choosen command
 *          line's option (in manage_command_line_options function).
 */
extern options_t *do_what_is_needed_from_command_line_options(int argc, char **argv);


/**
 * Frees the option structure
 * @param opt is the structure to be freed
 */
extern void free_options_t_structure(options_t *opt);

#endif /* #ifndef _RESTAURE_OPTIONS_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    restaure.h
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file restaure.h
 *
 * This file contains all the definitions of the functions and structures
 * that are used by 'restaure' program.
 */
#ifndef _RESTAURE_H_
#define _RESTAURE_H_

/* Configuration from ./configure script */
#include "config.h"


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <glib.h>
#include <glib/gi18n-lib.h>
#include <sys/types.h>
#include <pwd.h>
#include <grp.h>

#include <libsauvegarde.h>

#include "options.h"

/**
 * @struct res_struct_t
 * @brief This structure is used to keep all parameters for restaure's
 *        program.
 */
typedef struct
{
    options_t *opt;  /**< Program's options                                        */
    comm_t *comm;    /**< Communication structure to operate with serveur's server */
    gchar *hostname; /**< Host name where the program is executing itself          */
} res_struct_t;


/**
 * @def RESTAURE_DATE
 * Defines restaure's creation date
 *
 * @def RESTAURE_AUTHORS
 * Defines restaure's main authors
 *
 * @def RESTAURE_LICENSE
 * Defines restaure's license (at least GPL v2)
 *
 * @def RESTAURE_VERSION
 * Defines restaure's version (which may be different of Sauvegarde's whole
 * project and programs that composes it).

 * @def PROGRAM_NAME
 * Defines the main program name for this part (restaure + ciseaux +
 * antememoire).
 */
#define RESTAURE_AUTHORS ("Olivier DELHOMME <olivier.delhomme@free.fr>")
#define RESTAURE_DATE _("15 08 2015")
#define RESTAURE_LICENSE _("GPL v3 or later")
#define RESTAURE_VERSION _("0.0.2")
#define PROGRAM_NAME ("restaure")



#endif /* #ifndef _RESTAURE_OPTIONS_H_ */
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    restaure.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */

/**
 * @file restaure.c
 * This program should be able to restaure files.
 */

#include "restaure.h"

static res_struct_t *init_res_struct(int argc, char **argv);
static gchar *encode_to_base64(gchar *string);
static query_t *get_user_infos(gchar *hostname, gchar *filename, gchar *date);
static GSList *get_files_from_serveur(res_struct_t *res_struct, query_t *query);
static void print_all_files(res_struct_t *res_struct, query_t *query);
static void restore_data_to_stream(res_struct_t *res_struct, GFileOutputStream *stream, GSList *hash_list);
static void create_file(res_struct_t *res_struct, meta_data_t *meta);
static void restore_last_file(res_struct_t *res_struct, query_t *query);
static void free_res_struct_t(res_struct_t *res_struct);

/**
 * Inits a res_struct_t * structure. Manages the command line options.
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 * @returns a res_struct_t * structure containing all of what is needed
 *          by restaure program.
 */
static res_struct_t *init_res_struct(int argc, char **argv)
{
    res_struct_t *res_struct = NULL;
    gchar *conn = NULL;



    res_struct = (res_struct_t *) g_malloc0(sizeof(res_struct_t));

    res_struct->hostname = (gchar *) g_get_host_name();

    res_struct->opt = do_what_is_needed_from_command_line_options(argc, argv);

    if (res_struct->opt != NULL && res_struct->opt->ip != NULL)
        {
            /* We keep conn string into comm_t structure: do not free it ! */
            conn = make_connexion_string(res_struct->opt->ip, res_struct->opt->port);
            res_struct->comm = init_comm_struct(conn);
        }
    else
        {
            /* This should never happen because we have default values... */
            res_struct->comm = NULL;
        }

    return res_struct;
}


/**
 * Encodes a gchar string into a base64 formated gchar * string.
 * @param string is the gchar string to be encoded (MUST be 0 terminated).
 * @returns a newly allocated gchar * string in base64 or NULL.
 */
static gchar *encode_to_base64(gchar *string)
{
    gchar *encoded_string = NULL;

    if (string != NULL)
        {
            encoded_string = g_base64_encode((const guchar *) string, strlen(string));
        }

    return encoded_string;
}



/**
 * Gets all user infos and fills a query_t * structure accordingly.
 * @param hostname the hostname where the program is run
 * @param filename is the name of the file we want to restore.
 * @param date is the date of the version of this file.
 * @return a pointer to a newly allocated query_t structure that may be
 *         freed when no longer needed.
 */
static query_t *get_user_infos(gchar *hostname, gchar *filename, gchar *date)
{
    uid_t uid;
    struct passwd *pass = NULL;
    struct group *grp = NULL;
    query_t *query = NULL;
    gchar *the_uid = NULL;
    gchar *the_gid = NULL;
    gchar *owner = NULL;
    gchar *group = NULL;
    gchar *encoded_date = NULL;
    gchar *encoded_filename = NULL;

    uid = geteuid();
    pass = getpwuid(uid);

    if (pass != NULL)
        {
            grp = getgrgid(pass->pw_gid);
            group = g_strdup(grp->gr_name);
            owner = g_strdup(pass->pw_name);
            the_uid = g_strdup_printf("%d", uid);
            the_gid = g_strdup_printf("%d", pass->pw_gid);

            encoded_filename = encode_to_base64(filename);
            encoded_date = encode_to_base64(date);

            query = init_query_structure(hostname, the_uid, the_gid, owner, group, encoded_filename, encoded_date);
            print_debug(_("hostname: %s, uid: %s, gid: %s, owner: %s, group: %s\n"), hostname, the_uid, the_gid, owner, group);
        }

    return query;
}


/**
 * Gets the file the serveur_metat_data_t * file list if any
 * @param res_struct is the main structure for restaure program.
 * @param query is the structure that contains everything needed to
 *        query the serveur (and filter a bit). It must not be NULL.
 * @returns a GSList * of serveur_meta_data_t *
 */
static GSList *get_files_from_serveur(res_struct_t *res_struct, query_t *query)
{
    gchar *request = NULL;
    json_t *root = NULL;
    GSList *list = NULL;    /** List of serveur_meta_data_t * returned by this function */
    gint res = CURLE_FAILED_INIT;

    if (res_struct != NULL && query != NULL)
        {
            if (query->date == NULL)
                {
                    request = g_strdup_printf("/File/List.json?hostname=%s&uid=%s&gid=%s&owner=%s&group=%s&filename=%s", query->hostname, query->uid, query->gid, query->owner, query->group, query->filename);
                }
            else
                {
                    request = g_strdup_printf("/File/List.json?hostname=%s&uid=%s&gid=%s&owner=%s&group=%s&filename=%s&date=%s", query->hostname, query->uid, query->gid, query->owner, query->group, query->filename, query->date);
                }

            print_debug(_("Query is: %s\n"), request);
            res = get_url(res_struct->comm, request);

            if (res == CURLE_OK && res_struct->comm->buffer != NULL)
                {
                    root = load_json(res_struct->comm->buffer);

                    list = extract_smeta_gslist_from_file_list(root);
                    list = g_slist_sort(list, compare_filenames);

                    json_decref(root);
                    res_struct->comm->buffer = free_variable(res_struct->comm->buffer);
                }

            free_variable(request);
        }

    return list;
}


/**
 * Prints all saved files
 * @param res_struct is the main structure for restaure program.
 * @param query is the structure that contains everything needed to
 *        query the serveur (and filter a bit). It must not be NULL.
 */
static void print_all_files(res_struct_t *res_struct, query_t *query)
{
    GSList *list = NULL;   /** List of serveur_meta_data_t * */
    GSList *head = NULL;   /** head of the list to be freed  */
    serveur_meta_data_t *smeta = NULL;

    if (res_struct != NULL && query != NULL)
        {
            list = get_files_from_serveur(res_struct, query);
            head = list;

            while (list != NULL)
                {
                    smeta = (serveur_meta_data_t *) list->data;
                    print_smeta_to_screen(smeta);
                    free_smeta_data_t(smeta);

                    list = g_slist_next(list);
                }

            g_slist_free(head);
        }
}


/**
 * Writes data obtained from the serveur with the hash_list hashs
 * to the stream.
 * @param stream is the stream where we are writing data (MUST be opened
 *        and not NULL)
 * @param hash_list list of hashs of the file to be restored
 * @todo error management.
 */
static void restore_data_to_stream(res_struct_t *res_struct, GFileOutputStream *stream, GSList *hash_list)
{
    gchar *hash = NULL;
    hash_data_t *hash_data = NULL;
    GError *error = NULL;
    gchar *request = NULL;
    gint res = CURLE_FAILED_INIT;

    if (stream != NULL)
        {
            while (hash_list != NULL)
                {
                    hash_data = hash_list->data;
                    hash = hash_to_string(hash_data->hash);
                    request = g_strdup_printf("/Data/%s.json", hash);

                    print_debug(_("Query is: %s\n"), request);

                    /* This call fills res_struct->comm->buffer */
                    res = get_url(res_struct->comm, request);

                    if (res == CURLE_OK)
                        {
                            /** We need to save the retrieved buffer */
                            if (res_struct->comm->buffer != NULL)
                                {
                                    hash_data = convert_json_to_hash_data(res_struct->comm->buffer);
                                    res_struct->comm->buffer = free_variable(res_struct->comm->buffer);

                                    if (hash_data != NULL)
                                        {
                                            g_output_stream_write((GOutputStream *) stream, hash_data->data, hash_data->read, NULL, &error);

                                            free_hash_data_t_structure(hash_data);
                                        }
                                    else
                                        {
                                            print_error(__FILE__, __LINE__, _("Error while trying to restore %s hash\n"), hash);
                                        }
                                }
                        }
                    else
                        {
                            print_error(__FILE__, __LINE__, _("Error while getting hash %s"), hash);
                        }

                    hash_list = g_slist_next(hash_list);
                    free_variable(request);
                    free_variable(hash);
                }
        }

}


/**
 * Creates the file to be restored.
 * @param res_struct is the main structure for restaure program (used here
 *        to communicate with serveur's server).
 * @param meta is the whole meta_data file describing the file to be
 *        restored
 */
static void create_file(res_struct_t *res_struct, meta_data_t *meta)
{
    GFile *file = NULL;
    gchar *basename = NULL;    /** basename for the file to be restored     */
    gchar *cwd = NULL;         /** current working directory                */
    gchar *filename = NULL;    /** filename of the restored file            */
    GFileOutputStream *stream =  NULL;
    GError *error = NULL;


    if (meta != NULL)
        {
            /* get the basename of the file to be restored */
            basename = g_path_get_basename(meta->name);

            /* gets the current directory to make the file to be restored in it */
            cwd = g_get_current_dir();
            filename = g_build_filename(cwd, basename, NULL);
            print_debug(_("filename to restore: %s\n"), filename);
            file = g_file_new_for_path(filename);

            if (g_strcmp0("", meta->link) == 0)
                {
                    stream = g_file_replace(file, NULL, TRUE, G_FILE_CREATE_NONE, NULL, &error);

                    if (stream != NULL)
                        {
                            restore_data_to_stream(res_struct, stream, meta->hash_data_list);

                            g_output_stream_close((GOutputStream *) stream, NULL, &error);
                            free_object(stream);
                        }
                    else if (error != NULL)
                        {
                            print_error(__FILE__, __LINE__, _("Error: unable to open file %s to write datas in it (%s).\n"), filename, error->message);
                            free_variable(error);
                        }

                    /* Setting before closing the file does not alter access and modification time */
                    set_file_attributes(file, meta);
                }
            else
                {
                    make_symbolic_link(file, meta->link);
                }

            free_object(file);
            free_variable(cwd);
            free_variable(basename);
            free_variable(filename);
        }
}


/**
 * Restores the last file that the fetched list contains.
 * @param res_struct is the main structure for restaure program.
 * @param query is the structure that contains everything needed to
 *        query the serveur (and filter a bit). It must not be NULL.
 */
static void restore_last_file(res_struct_t *res_struct, query_t *query)
{
    GSList *list = NULL;      /** List of serveur_meta_data_t *            */
    GSList *last = NULL;      /** last element of the list                 */
    serveur_meta_data_t *smeta = NULL;
    meta_data_t *meta = NULL;

    if (res_struct != NULL && query != NULL)
        {
            list = get_files_from_serveur(res_struct, query);
            last = g_slist_last(list);

            if (last != NULL)
                {
                    smeta = (serveur_meta_data_t *) last->data;
                    meta = smeta->meta;

                    print_debug(_("File to be restored: type %d, inode: %ld, mode: %d, atime: %ld, ctime: %ld, mtime: %ld, size: %ld, filename: %s, owner: %s, group: %s, uid: %d, gid: %d\n"), meta->file_type, meta->inode, meta->mode, meta->atime, meta->ctime, meta->mtime, meta->size, meta->name, meta->owner, meta->group, meta->uid, meta->gid);

                    create_file(res_struct, meta);
                }

            g_slist_free_full(list, gslist_free_smeta);
        }
}


/**
 * Frees a previously allocated res_struct_t * structure.
 * @param res_struct is the res_struct_t * structure to be freed.
 */
static void free_res_struct_t(res_struct_t *res_struct)
{
    if (res_struct != NULL)
        {
            free_options_t_structure(res_struct->opt);
            free_comm_t(res_struct->comm);
            free_variable(res_struct->hostname);
            free_variable(res_struct);
        }
}


/**
 * Main function
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 * @returns
 */
int main(int argc, char **argv)
{
    res_struct_t *res_struct = NULL;
    query_t *query =  NULL;


    #if !GLIB_CHECK_VERSION(2, 36, 0)
        g_type_init();  /** g_type_init() is deprecated since glib 2.36 */
    #endif

    init_international_languages();

    res_struct = init_res_struct(argc, argv);

    if (res_struct != NULL && res_struct->opt != NULL && res_struct->comm != NULL)
        {

            if (res_struct->opt->list != NULL)
                {
                    query = get_user_infos(res_struct->hostname, res_struct->opt->list, res_struct->opt->date);
                    print_all_files(res_struct, query);
                    free_query_structure(query);
                }

            if (res_struct->opt->restore != NULL)
                {
                    query = get_user_infos(res_struct->hostname, res_struct->opt->restore, res_struct->opt->date);
                    fprintf(stdout, "We should restore %s!\n", res_struct->opt->restore);
                    restore_last_file(res_struct, query);
                    free_query_structure(query);
                }

            free_res_struct_t(res_struct);

            return EXIT_SUCCESS;
        }
    else
        {
            return EXIT_FAILURE;
        }
}
/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
/*
 *    options.c
 *    This file is part of "Sauvegarde" project.
 *
 *    (C) Copyright 2015 Olivier Delhomme
 *     e-mail : olivier.delhomme@free.fr
 *
 *    "Sauvegarde" is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    "Sauvegarde" is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with "Sauvegarde".  If not, see <http://www.gnu.org/licenses/>
 */
/**
 * @file restaure/options.c
 *
 *  This file contains all the functions to manage command line options for
 *  'restaure' program.
 */

#include "restaure.h"

static void print_selected_options(options_t *opt);
static void read_from_group_all(GKeyFile *keyfile, gchar *filename);
static void read_from_group_serveur(options_t *opt, GKeyFile *keyfile, gchar *filename);
static options_t *manage_command_line_options(int argc, char **argv);


/**
 * Prints options as selected when invoking the program with -v option
 * @param opt the options_t * structure that contains all selected options
 *        from the command line and that will be used by the program.
 */
static void print_selected_options(options_t *opt)
{
    if (opt != NULL)
        {
            fprintf(stdout, _("\n%s options are:\n"), PROGRAM_NAME);
            print_string_option(_("Configuration file: %s\n"), opt->configfile);
            print_string_option(_("serveur's IP address: %s\n"), opt->ip);
            fprintf(stdout, _("serveur's port number: %d\n"), opt->port);
        }
}


/**
 * Reads keys in keyfile if group GN_ALL is in that keyfile.
 * @param keyfile is the GKeyFile structure that is used by glib to read
 *        groups and keys from.
 * @param filename : the filename of the configuration file to read from
 */
static void read_from_group_all(GKeyFile *keyfile, gchar *filename)
{
    gboolean debug = FALSE;

    if (keyfile != NULL && filename != NULL && g_key_file_has_group(keyfile, GN_ALL) == TRUE)
        {
            debug = read_boolean_from_file(keyfile, filename, GN_ALL, KN_DEBUG_MODE, _("Could not load debug mode configuration from file."));

            set_debug_mode(debug);
        }
}


/**
 * Reads keys in keyfile if groupname is in that keyfile and fills
 * options_t *opt structure accordingly.
 * @param[in,out] opt : options_t * structure to store options read from the
 *                configuration file "filename".
 * @param keyfile is the GKeyFile structure that is used by glib to read
 *        groups and keys from.
 * @param filename : the filename of the configuration file to read from
 */
static void read_from_group_serveur(options_t *opt, GKeyFile *keyfile, gchar *filename)
{
    gint port = 0;

    if (opt != NULL && keyfile != NULL && filename != NULL && g_key_file_has_group(keyfile, GN_SERVEUR) == TRUE)
        {
            /* Reading the port number if any */
            port = read_int_from_file(keyfile, filename, GN_SERVEUR, KN_SERVEUR_PORT, _("Could not load serveur port number from file."));

            if (port > 1024 && port < 65535)
                {
                    opt->port = port;
                }

            /* Reading IP address of serveur's host if any */
            opt->ip = read_string_from_file(keyfile, filename, GN_SERVEUR, KN_SERVEUR_IP, _("Could not load cache database name"));
        }
}


/**
 * Reads from the configuration file "filename" and fills the options_t *
 * opt structure.
 * @param[in,out] opt : options_t * structure to store options read from
 *                the configuration file "filename"
 * @param filename : the filename of the configuration file to read from
 */
static void read_from_configuration_file(options_t *opt, gchar *filename)
{
    GKeyFile *keyfile = NULL;      /** Configuration file parser   */
    GError *error = NULL;          /** Glib error handling         */

    if (filename != NULL)
        {

            if (opt->configfile != NULL)
                {
                    free_variable(opt->configfile);
                }
            opt->configfile = g_strdup(filename);

            print_debug(_("Reading configuration from file %s\n"), filename);

            keyfile = g_key_file_new();

            if (g_key_file_load_from_file(keyfile, filename, G_KEY_FILE_KEEP_COMMENTS, &error))
                {
                    read_from_group_all(keyfile, filename);
                    read_from_group_serveur(opt, keyfile, filename);
                }
            else if (error != NULL)
                {
                    print_error(__FILE__, __LINE__, _("Failed to open %s configuration file : %s\n"), filename, error->message);
                    error = free_error(error);
                }

            g_key_file_free(keyfile);
        }
}


/**
 * This function parses command line options. It sets the options in this
 * order. It means that the value used for an option is the one set in the
 * lastest step.
 * 0) default values are set into the options_t * structure
 * 1) reads the default configuration file if any.
 * 2) reads the configuration file mentionned on the command line.
 * 3) sets the command line options (except for the list of directories,
 *    all other values are replaced by thoses in the command line)
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 * @returns options_t structure malloc'ed and filled upon choosen command
 *          line's option
 */
static options_t *manage_command_line_options(int argc, char **argv)
{
    gboolean version = FALSE;      /** True if -v was selected on the command line                */
    gint debug = -4;               /** 0 == FALSE and other values == TRUE                        */
    gchar *configfile = NULL;      /** filename for the configuration file if any                 */
    gchar *ip =  NULL;             /** IP address where is located serveur's program              */
    gint port = 0;                 /** Port number on which to send things to the server          */
    gchar *list = NULL;            /** Should contain a filename or a directory to filter out     */
    gchar *restore = NULL;         /** Must contain a filename or a directory name to be restored */
    gchar *date = NULL;

    GOptionEntry entries[] =
    {
        { "version", 'v', 0, G_OPTION_ARG_NONE, &version, N_("Prints program version."), NULL},
        { "list", 'l', 0, G_OPTION_ARG_FILENAME, &list, N_("Gives a list of saved files that correspond to the given REGEX."), "REGEX"},
        { "restore", 'r', 0, G_OPTION_ARG_FILENAME, &restore, N_("Restore requested filename (REGEX) (by default latest version)."), "REGEX"},
        { "date", 't', 0, G_OPTION_ARG_STRING, &date, N_("restores the selected file at that specific DATE."), "DATE"},
        { "debug", 'd', 0,  G_OPTION_ARG_INT, &debug, N_("Activates (1) or desactivates (0) debug mode."), N_("BOOLEAN")},
        { "configuration", 'c', 0, G_OPTION_ARG_STRING, &configfile, N_("Specify an alternative configuration file."), N_("FILENAME")},
        { "ip", 'i', 0, G_OPTION_ARG_STRING, &ip, N_("IP address where serveur program is."), "IP"},
        { "port", 'p', 0, G_OPTION_ARG_INT, &port, N_("Port NUMBER on which serveur program is listening."), N_("NUMBER")},
        { NULL }
    };

    GError *error = NULL;
    GOptionContext *context;
    options_t *opt = NULL;    /** Structure to manage program's options            */
    gchar *bugreport = NULL;  /** Bug Report message                               */
    gchar *summary = NULL;    /** Abstract for the program                         */
    gchar *defaultconfigfilename = NULL;

    bugreport = g_strconcat(_("Please report bugs to: "), PACKAGE_BUGREPORT, NULL);
    summary = g_strdup(_("This program is restoring files from serveur's server.\n"));
    context = g_option_context_new("");

    set_debug_mode(ENABLE_DEBUG);

    set_option_context_options(context, entries, TRUE, bugreport, summary);

    if (!g_option_context_parse(context, &argc, &argv, &error))
        {
            g_print(_("Option parsing failed: %s\n"), error->message);
            exit(EXIT_FAILURE);
        }

    /* 0) Setting default values */

    opt = (options_t *) g_malloc0(sizeof(options_t));

    opt->configfile = NULL;
    opt->list = NULL;
    opt->restore = NULL;
    opt->ip = g_strdup("localhost");
    opt->port = 5468;


    /* 1) Reading options from default configuration file
     *    note: restore option will never be read into the configuration
     *          file.
     */
    defaultconfigfilename = get_probable_etc_path(PROGRAM_NAME, "restaure.conf");
    read_from_configuration_file(opt,  defaultconfigfilename);
    defaultconfigfilename = free_variable(defaultconfigfilename);

    set_debug_mode_upon_cmdl(debug);


    /* 2) Reading the configuration from the configuration file specified
     *    on the command line (if any).
     *    note: same note than 1) applies here too.
     */
    if (configfile != NULL)
        {
            read_from_configuration_file(opt, configfile);
        }


    /* 3) retrieving other options from the command line.
     */
    opt->version = version; /* only TRUE if -v or --version was invoked */

    if (date != NULL)
        {
            opt->date = g_strdup(date);
        }

    if (list != NULL)
        {
            opt->list = g_strdup(list);
        }

    if (restore != NULL)
        {
            opt->restore = g_strdup(restore);
        }

    if (ip != NULL)
        {
            free_variable(opt->ip);
            opt->ip = g_strdup(ip);
        }

    if (port > 1024 && port < 65535)
        {
            opt->port = port;
        }

    g_option_context_free(context);
    free_variable(ip);
    free_variable(bugreport);
    free_variable(summary);
    free_variable(list);
    free_variable(restore);
    free_variable(date);

    return opt;
}


/**
 * Decides what to do upon command lines options passed to the program
 * @param argc : number of arguments given on the command line.
 * @param argv : an array of strings that contains command line arguments.
 * @returns options_t structure malloc'ed and filled upon choosen command
 *          line's option (in manage_command_line_options function).
 */
options_t *do_what_is_needed_from_command_line_options(int argc, char **argv)
{
    options_t *opt = NULL;  /** Structure to manage options from the command line can be freed when no longer needed */

    opt = manage_command_line_options(argc, argv);

    if (opt != NULL)
        {
            if (opt->version == TRUE)
                {
                    print_program_version(PROGRAM_NAME, RESTAURE_DATE, RESTAURE_VERSION, RESTAURE_AUTHORS, RESTAURE_LICENSE);
                    print_libraries_versions(PROGRAM_NAME);
                    print_selected_options(opt);
                    exit(EXIT_SUCCESS);
                }
        }

    return opt;
}


/**
 * Frees the option structure
 * @param opt is the structure to be freed
 */
void free_options_t_structure(options_t *opt)
{
    if (opt != NULL)
        {
            free_variable(opt->list);
            free_variable(opt->restore);
            free_variable(opt->date);
            free_variable(opt->configfile);
            free_variable(opt->ip);
            free_variable(opt);
        }
}
